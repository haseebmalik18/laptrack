{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 58, "column": 0}, "map": {"version":3,"sources":["file:///Users/haseebulhaqmalik/Desktop/lap-lens/src/analysis/corner-database.ts"],"sourcesContent":["import * as fs from 'fs';\nimport * as path from 'path';\nimport { Corner, CornerDirection, CornerType } from './corner-detector';\nimport { BrakingZone, BrakingIntensity } from './braking-zone-detector';\n\nexport interface BrakingZoneEntry {\n  entryDistance: number;\n  peakDistance: number;\n  exitDistance: number;\n  entrySpeed: number;\n  minSpeed: number;\n  exitSpeed: number;\n  speedLoss: number;\n  peakBrakePressure: number;\n  avgBrakePressure: number;\n  peakDeceleration: number;\n  avgDeceleration: number;\n  brakingDistance: number;\n  brakingDuration: number;\n  intensity: BrakingIntensity;\n  isTrailBraking: boolean;\n}\n\nexport interface CornerDatabaseEntry {\n  number: number;\n  name?: string;\n  entryDistance: number;\n  apexDistance: number;\n  exitDistance: number;\n  type: CornerType;\n  direction: CornerDirection;\n  brakingZone?: BrakingZoneEntry;\n}\n\nexport interface TrackCornerDatabase {\n  trackId: number;\n  trackName: string;\n  trackLength: number;\n  totalCorners: number;\n  corners: CornerDatabaseEntry[];\n  createdAt: string;\n  updatedAt: string;\n}\n\nexport class CornerDatabase {\n  private databaseDir: string;\n\n  constructor(databaseDir: string = './corners') {\n    this.databaseDir = databaseDir;\n    if (!fs.existsSync(databaseDir)) {\n      fs.mkdirSync(databaseDir, { recursive: true });\n    }\n  }\n\n  private sanitizeTrackName(trackName: string): string {\n    const match = trackName.match(/\\(([^)]+)\\)/);\n    const baseName = match ? match[1] : trackName;\n\n    return baseName\n      .toLowerCase()\n      .trim()\n      .replace(/\\s+/g, '-')\n      .replace(/[^a-z0-9-]/g, '');\n  }\n\n  private getFilePath(trackName: string): string {\n    const sanitized = this.sanitizeTrackName(trackName);\n    return path.join(this.databaseDir, `${sanitized}.json`);\n  }\n\n  private getLegacyFilePath(trackId: number): string {\n    return path.join(this.databaseDir, `track_${trackId}.json`);\n  }\n\n  hasTrackData(trackName: string, trackId?: number): boolean {\n    const filePath = this.getFilePath(trackName);\n    if (fs.existsSync(filePath)) return true;\n\n    if (trackId !== undefined) {\n      const legacyPath = this.getLegacyFilePath(trackId);\n      return fs.existsSync(legacyPath);\n    }\n\n    return false;\n  }\n\n  loadTrackCorners(trackName: string, trackId?: number): TrackCornerDatabase | null {\n    let filePath = this.getFilePath(trackName);\n\n    if (!fs.existsSync(filePath) && trackId !== undefined) {\n      const legacyPath = this.getLegacyFilePath(trackId);\n      if (fs.existsSync(legacyPath)) {\n        filePath = legacyPath;\n      }\n    }\n\n    if (!fs.existsSync(filePath)) {\n      return null;\n    }\n\n    try {\n      const data = fs.readFileSync(filePath, 'utf-8');\n      return JSON.parse(data) as TrackCornerDatabase;\n    } catch (error) {\n      console.error(`Failed to load corner database for track ${trackName}:`, error);\n      return null;\n    }\n  }\n\n  saveTrackCorners(\n    trackName: string,\n    trackId: number,\n    trackLength: number,\n    corners: Corner[],\n    brakingZones?: BrakingZone[]\n  ): void {\n    const filePath = this.getFilePath(trackName);\n    const isUpdate = fs.existsSync(filePath);\n\n    let createdAt = new Date().toISOString();\n    if (isUpdate) {\n      const existing = this.loadTrackCorners(trackName, trackId);\n      if (existing) {\n        createdAt = existing.createdAt;\n      }\n    }\n\n    const brakingZoneMap = new Map<number, BrakingZone>();\n    if (brakingZones) {\n      for (const corner of corners) {\n        const cornerNumber = corners.indexOf(corner) + 1;\n        const candidateZones = brakingZones.filter((zone) => {\n          const distanceToCorner = corner.entryDistance - zone.exitDistance;\n          return distanceToCorner >= -100 && distanceToCorner <= 50;\n        });\n\n        if (candidateZones.length > 0) {\n          const primaryZone = candidateZones.reduce((best, current) => {\n            const bestDistance = Math.abs(corner.entryDistance - best.exitDistance);\n            const currentDistance = Math.abs(corner.entryDistance - current.exitDistance);\n            return currentDistance < bestDistance ? current : best;\n          });\n          brakingZoneMap.set(cornerNumber, primaryZone);\n        }\n      }\n    }\n\n    const databaseEntries: CornerDatabaseEntry[] = corners.map((corner, index) => {\n      const cornerNumber = index + 1;\n      const entry: CornerDatabaseEntry = {\n        number: cornerNumber,\n        entryDistance: Math.round(corner.entryDistance),\n        apexDistance: Math.round(corner.apexDistance),\n        exitDistance: Math.round(corner.exitDistance),\n        type: corner.type,\n        direction: corner.direction,\n      };\n\n      const brakingZone = brakingZoneMap.get(cornerNumber);\n      if (brakingZone) {\n        entry.brakingZone = {\n          entryDistance: Math.round(brakingZone.entryDistance),\n          peakDistance: Math.round(brakingZone.peakDistance),\n          exitDistance: Math.round(brakingZone.exitDistance),\n          entrySpeed: Math.round(brakingZone.entrySpeed),\n          minSpeed: Math.round(brakingZone.minSpeed),\n          exitSpeed: Math.round(brakingZone.exitSpeed),\n          speedLoss: Math.round(brakingZone.speedLoss),\n          peakBrakePressure: Math.round(brakingZone.peakBrakePressure * 100) / 100,\n          avgBrakePressure: Math.round(brakingZone.avgBrakePressure * 100) / 100,\n          peakDeceleration: Math.round(brakingZone.peakDeceleration * 100) / 100,\n          avgDeceleration: Math.round(brakingZone.avgDeceleration * 100) / 100,\n          brakingDistance: Math.round(brakingZone.brakingDistance),\n          brakingDuration: Math.round(brakingZone.brakingDuration * 100) / 100,\n          intensity: brakingZone.intensity,\n          isTrailBraking: brakingZone.isTrailBraking,\n        };\n      }\n\n      return entry;\n    });\n\n    const database: TrackCornerDatabase = {\n      trackId,\n      trackName,\n      trackLength: Math.round(trackLength),\n      totalCorners: corners.length,\n      corners: databaseEntries,\n      createdAt,\n      updatedAt: new Date().toISOString(),\n    };\n\n    fs.writeFileSync(filePath, JSON.stringify(database, null, 2));\n  }\n\n  findCornerAtDistance(trackName: string, distance: number, trackId?: number, tolerance: number = 10): CornerDatabaseEntry | null {\n    const trackData = this.loadTrackCorners(trackName, trackId);\n\n    if (!trackData) {\n      return null;\n    }\n\n    for (const corner of trackData.corners) {\n      if (distance >= corner.entryDistance - tolerance && distance <= corner.exitDistance + tolerance) {\n        return corner;\n      }\n    }\n\n    return null;\n  }\n\n  getCornerPhase(trackName: string, distance: number, trackId?: number, tolerance: number = 10): 'entry' | 'apex' | 'exit' | null {\n    const corner = this.findCornerAtDistance(trackName, distance, trackId, tolerance);\n\n    if (!corner) {\n      return null;\n    }\n\n    const distToEntry = Math.abs(distance - corner.entryDistance);\n    const distToApex = Math.abs(distance - corner.apexDistance);\n    const distToExit = Math.abs(distance - corner.exitDistance);\n\n    if (distToEntry <= distToApex && distToEntry <= distToExit) {\n      return 'entry';\n    } else if (distToApex <= distToEntry && distToApex <= distToExit) {\n      return 'apex';\n    } else {\n      return 'exit';\n    }\n  }\n\n  listAvailableTracks(): string[] {\n    if (!fs.existsSync(this.databaseDir)) {\n      return [];\n    }\n\n    const files = fs.readdirSync(this.databaseDir)\n      .filter(f => f.endsWith('.json'))\n      .map(f => f.replace('.json', ''));\n\n    return files.sort();\n  }\n\n  deleteTrackCorners(trackName: string, trackId?: number): boolean {\n    const filePath = this.getFilePath(trackName);\n\n    if (fs.existsSync(filePath)) {\n      fs.unlinkSync(filePath);\n      return true;\n    }\n\n    if (trackId !== undefined) {\n      const legacyPath = this.getLegacyFilePath(trackId);\n      if (fs.existsSync(legacyPath)) {\n        fs.unlinkSync(legacyPath);\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  getAllTrackData(): TrackCornerDatabase[] {\n    const trackNames = this.listAvailableTracks();\n    const allData: TrackCornerDatabase[] = [];\n\n    for (const trackName of trackNames) {\n      const data = this.loadTrackCorners(trackName);\n      if (data) {\n        allData.push(data);\n      }\n    }\n\n    return allData;\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 253, "column": 0}, "map": {"version":3,"sources":["file:///Users/haseebulhaqmalik/Desktop/lap-lens/src/analysis/speed-comparison.ts"],"sourcesContent":["import { NormalizedTelemetryPoint } from '../types/f1-2024-packets';\nimport { AlignedLaps } from './lap-aligner';\nimport { CornerDatabase, CornerDatabaseEntry } from './corner-database';\n\nexport interface SpeedPoint {\n  lapA: number;\n  lapB: number;\n  delta: number;\n}\n\nexport interface BrakingComparison {\n  brakingPoint: SpeedPoint;\n  peakBrake: SpeedPoint;\n  brakingDistance: { lapA: number; lapB: number; delta: number };\n  avgBrakePressure: SpeedPoint;\n}\n\nexport interface CornerSpeedComparison {\n  cornerNumber: number;\n  cornerName?: string;\n  entryDistance: number;\n  apexDistance: number;\n  exitDistance: number;\n\n  entrySpeed: SpeedPoint;\n  apexSpeed: SpeedPoint;\n  exitSpeed: SpeedPoint;\n  minSpeed: SpeedPoint;\n\n  entryTime: { lapA: number; lapB: number };\n  exitTime: { lapA: number; lapB: number };\n  timeDelta: number;\n\n  cornerLength: number;\n  avgThrottle: SpeedPoint;\n  avgBrake: SpeedPoint;\n\n  brakingComparison?: BrakingComparison;\n}\n\nexport interface AccelerationZone {\n  startDistance: number;\n  endDistance: number;\n  distance: number;\n\n  startSpeed: SpeedPoint;\n  endSpeed: SpeedPoint;\n\n  avgAcceleration: SpeedPoint;\n  avgThrottle: SpeedPoint;\n\n  duration: { lapA: number; lapB: number };\n  timeDelta: number;\n\n  precedingCorner?: number;\n  followingCorner?: number;\n}\n\nexport interface SpeedComparisonSummary {\n  totalTimeDelta: number;\n  totalDistance: number;\n\n  timeGainedInCorners: number;\n  timeGainedInAccelZones: number;\n\n  avgSpeedDelta: number;\n  maxSpeedDelta: number;\n  maxSpeedDeltaDistance: number;\n\n  fastestCornerGain: { cornerNumber: number; timeDelta: number };\n  slowestCornerLoss: { cornerNumber: number; timeDelta: number };\n\n  bestAccelZone: { zoneIndex: number; timeDelta: number };\n  worstAccelZone: { zoneIndex: number; timeDelta: number };\n}\n\nexport interface SpeedComparison {\n  corners: CornerSpeedComparison[];\n  accelerationZones: AccelerationZone[];\n  summary: SpeedComparisonSummary;\n}\n\nexport interface SpeedComparisonConfig {\n  accelThrottleThreshold: number;\n  minAccelZoneLength: number;\n  cornerSpeedTolerance: number;\n}\n\nexport class SpeedComparisonAnalyzer {\n  private config: SpeedComparisonConfig;\n  private cornerDb: CornerDatabase;\n\n  constructor(config: Partial<SpeedComparisonConfig> = {}) {\n    this.config = {\n      accelThrottleThreshold: config.accelThrottleThreshold ?? 0.5,\n      minAccelZoneLength: config.minAccelZoneLength ?? 50,\n      cornerSpeedTolerance: config.cornerSpeedTolerance ?? 5,\n    };\n    this.cornerDb = new CornerDatabase();\n  }\n\n  compareSpeed(\n    aligned: AlignedLaps,\n    trackName: string,\n    trackId?: number\n  ): SpeedComparison {\n    const corners = this.analyzeCorners(aligned, trackName, trackId);\n    const accelZones = this.detectAccelerationZones(aligned, corners);\n    const summary = this.calculateSummary(aligned, corners, accelZones);\n\n    return {\n      corners,\n      accelerationZones: accelZones,\n      summary,\n    };\n  }\n\n  private analyzeCorners(\n    aligned: AlignedLaps,\n    trackName: string,\n    trackId?: number\n  ): CornerSpeedComparison[] {\n    const trackData = this.cornerDb.loadTrackCorners(trackName, trackId);\n\n    if (!trackData) {\n      throw new Error(`No corner database found for track: ${trackName}`);\n    }\n\n    const { lapA, lapB } = aligned;\n    const comparisons: CornerSpeedComparison[] = [];\n\n    for (const corner of trackData.corners) {\n      const comparison = this.analyzeCorner(lapA, lapB, corner);\n      comparisons.push(comparison);\n    }\n\n    return comparisons;\n  }\n\n  private analyzeCorner(\n    lapA: NormalizedTelemetryPoint[],\n    lapB: NormalizedTelemetryPoint[],\n    corner: CornerDatabaseEntry\n  ): CornerSpeedComparison {\n    const tolerance = this.config.cornerSpeedTolerance;\n\n    const entryA = this.findPointAtDistance(lapA, corner.entryDistance, tolerance);\n    const entryB = this.findPointAtDistance(lapB, corner.entryDistance, tolerance);\n\n    const apexA = this.findPointAtDistance(lapA, corner.apexDistance, tolerance);\n    const apexB = this.findPointAtDistance(lapB, corner.apexDistance, tolerance);\n\n    const exitA = this.findPointAtDistance(lapA, corner.exitDistance, tolerance);\n    const exitB = this.findPointAtDistance(lapB, corner.exitDistance, tolerance);\n\n    const cornerPointsA = this.getPointsInRange(lapA, corner.entryDistance, corner.exitDistance);\n    const cornerPointsB = this.getPointsInRange(lapB, corner.entryDistance, corner.exitDistance);\n\n    const minSpeedA = Math.min(...cornerPointsA.map(p => p.speed));\n    const minSpeedB = Math.min(...cornerPointsB.map(p => p.speed));\n\n    const avgThrottleA = this.average(cornerPointsA.map(p => p.throttle));\n    const avgThrottleB = this.average(cornerPointsB.map(p => p.throttle));\n\n    const avgBrakeA = this.average(cornerPointsA.map(p => p.brake));\n    const avgBrakeB = this.average(cornerPointsB.map(p => p.brake));\n\n    const timeOffsetA = lapA[0].time;\n    const timeOffsetB = lapB[0].time;\n\n    const entryTimeA = entryA.time - timeOffsetA;\n    const entryTimeB = entryB.time - timeOffsetB;\n    const exitTimeA = exitA.time - timeOffsetA;\n    const exitTimeB = exitB.time - timeOffsetB;\n\n    const cornerDurationA = exitTimeA - entryTimeA;\n    const cornerDurationB = exitTimeB - entryTimeB;\n    const timeDelta = cornerDurationA - cornerDurationB;\n\n    let brakingComparison: BrakingComparison | undefined;\n    if (corner.brakingZone) {\n      brakingComparison = this.analyzeBraking(lapA, lapB, corner);\n    }\n\n    return {\n      cornerNumber: corner.number,\n      cornerName: corner.name,\n      entryDistance: corner.entryDistance,\n      apexDistance: corner.apexDistance,\n      exitDistance: corner.exitDistance,\n\n      entrySpeed: { lapA: entryA.speed, lapB: entryB.speed, delta: entryA.speed - entryB.speed },\n      apexSpeed: { lapA: apexA.speed, lapB: apexB.speed, delta: apexA.speed - apexB.speed },\n      exitSpeed: { lapA: exitA.speed, lapB: exitB.speed, delta: exitA.speed - exitB.speed },\n      minSpeed: { lapA: minSpeedA, lapB: minSpeedB, delta: minSpeedA - minSpeedB },\n\n      entryTime: { lapA: entryTimeA, lapB: entryTimeB },\n      exitTime: { lapA: exitTimeA, lapB: exitTimeB },\n      timeDelta,\n\n      cornerLength: corner.exitDistance - corner.entryDistance,\n      avgThrottle: { lapA: avgThrottleA, lapB: avgThrottleB, delta: avgThrottleA - avgThrottleB },\n      avgBrake: { lapA: avgBrakeA, lapB: avgBrakeB, delta: avgBrakeA - avgBrakeB },\n\n      brakingComparison,\n    };\n  }\n\n  private analyzeBraking(\n    lapA: NormalizedTelemetryPoint[],\n    lapB: NormalizedTelemetryPoint[],\n    corner: CornerDatabaseEntry\n  ): BrakingComparison | undefined {\n    if (!corner.brakingZone) return undefined;\n\n    const tolerance = this.config.cornerSpeedTolerance;\n    const zone = corner.brakingZone;\n\n    const brakingPointA = this.findPointAtDistance(lapA, zone.entryDistance, tolerance);\n    const brakingPointB = this.findPointAtDistance(lapB, zone.entryDistance, tolerance);\n\n    const peakBrakeA = this.findPointAtDistance(lapA, zone.peakDistance, tolerance);\n    const peakBrakeB = this.findPointAtDistance(lapB, zone.peakDistance, tolerance);\n\n    const brakePointsA = this.getPointsInRange(lapA, zone.entryDistance, zone.exitDistance);\n    const brakePointsB = this.getPointsInRange(lapB, zone.entryDistance, zone.exitDistance);\n\n    const avgBrakeA = this.average(brakePointsA.map(p => p.brake));\n    const avgBrakeB = this.average(brakePointsB.map(p => p.brake));\n\n    return {\n      brakingPoint: {\n        lapA: brakingPointA.speed,\n        lapB: brakingPointB.speed,\n        delta: brakingPointA.speed - brakingPointB.speed\n      },\n      peakBrake: {\n        lapA: peakBrakeA.brake,\n        lapB: peakBrakeB.brake,\n        delta: peakBrakeA.brake - peakBrakeB.brake\n      },\n      brakingDistance: {\n        lapA: zone.brakingDistance,\n        lapB: zone.brakingDistance,\n        delta: 0\n      },\n      avgBrakePressure: {\n        lapA: avgBrakeA,\n        lapB: avgBrakeB,\n        delta: avgBrakeA - avgBrakeB\n      },\n    };\n  }\n\n  private detectAccelerationZones(\n    aligned: AlignedLaps,\n    corners: CornerSpeedComparison[]\n  ): AccelerationZone[] {\n    const { lapA, lapB } = aligned;\n    const zones: AccelerationZone[] = [];\n\n    if (corners.length === 0) return zones;\n\n    if (corners[0].entryDistance > this.config.minAccelZoneLength) {\n      const zone = this.analyzeAccelerationZone(\n        lapA, lapB,\n        0,\n        corners[0].entryDistance,\n        undefined,\n        corners[0].cornerNumber\n      );\n      if (zone) zones.push(zone);\n    }\n\n    for (let i = 0; i < corners.length - 1; i++) {\n      const currentExit = corners[i].exitDistance;\n      const nextEntry = corners[i + 1].entryDistance;\n      const distance = nextEntry - currentExit;\n\n      if (distance >= this.config.minAccelZoneLength) {\n        const zone = this.analyzeAccelerationZone(\n          lapA, lapB,\n          currentExit,\n          nextEntry,\n          corners[i].cornerNumber,\n          corners[i + 1].cornerNumber\n        );\n        if (zone) zones.push(zone);\n      }\n    }\n\n    const lastCorner = corners[corners.length - 1];\n    const trackEnd = lapA[lapA.length - 1].distance;\n    if (trackEnd - lastCorner.exitDistance > this.config.minAccelZoneLength) {\n      const zone = this.analyzeAccelerationZone(\n        lapA, lapB,\n        lastCorner.exitDistance,\n        trackEnd,\n        lastCorner.cornerNumber,\n        undefined\n      );\n      if (zone) zones.push(zone);\n    }\n\n    return zones;\n  }\n\n  private analyzeAccelerationZone(\n    lapA: NormalizedTelemetryPoint[],\n    lapB: NormalizedTelemetryPoint[],\n    startDistance: number,\n    endDistance: number,\n    precedingCorner?: number,\n    followingCorner?: number\n  ): AccelerationZone | null {\n    const pointsA = this.getPointsInRange(lapA, startDistance, endDistance);\n    const pointsB = this.getPointsInRange(lapB, startDistance, endDistance);\n\n    if (pointsA.length < 2 || pointsB.length < 2) return null;\n\n    const avgThrottleA = this.average(pointsA.map(p => p.throttle));\n    const avgThrottleB = this.average(pointsB.map(p => p.throttle));\n\n    if (avgThrottleA < this.config.accelThrottleThreshold &&\n        avgThrottleB < this.config.accelThrottleThreshold) {\n      return null;\n    }\n\n    const startSpeedA = pointsA[0].speed;\n    const endSpeedA = pointsA[pointsA.length - 1].speed;\n    const startSpeedB = pointsB[0].speed;\n    const endSpeedB = pointsB[pointsB.length - 1].speed;\n\n    const durationA = pointsA[pointsA.length - 1].time - pointsA[0].time;\n    const durationB = pointsB[pointsB.length - 1].time - pointsB[0].time;\n\n    const avgAccelA = durationA > 0 ? (endSpeedA - startSpeedA) / 3.6 / durationA : 0;\n    const avgAccelB = durationB > 0 ? (endSpeedB - startSpeedB) / 3.6 / durationB : 0;\n\n    const timeDelta = durationA - durationB;\n\n    return {\n      startDistance,\n      endDistance,\n      distance: endDistance - startDistance,\n\n      startSpeed: { lapA: startSpeedA, lapB: startSpeedB, delta: startSpeedA - startSpeedB },\n      endSpeed: { lapA: endSpeedA, lapB: endSpeedB, delta: endSpeedA - endSpeedB },\n\n      avgAcceleration: { lapA: avgAccelA, lapB: avgAccelB, delta: avgAccelA - avgAccelB },\n      avgThrottle: { lapA: avgThrottleA, lapB: avgThrottleB, delta: avgThrottleA - avgThrottleB },\n\n      duration: { lapA: durationA, lapB: durationB },\n      timeDelta,\n\n      precedingCorner,\n      followingCorner,\n    };\n  }\n\n  private calculateSummary(\n    aligned: AlignedLaps,\n    corners: CornerSpeedComparison[],\n    accelZones: AccelerationZone[]\n  ): SpeedComparisonSummary {\n    const { lapA } = aligned;\n    const totalDistance = lapA[lapA.length - 1].distance - lapA[0].distance;\n\n    const timeGainedInCorners = corners.reduce((sum, c) => sum + c.timeDelta, 0);\n    const timeGainedInAccelZones = accelZones.reduce((sum, z) => sum + z.timeDelta, 0);\n\n    const timeOffsetA = lapA[0].time;\n    const timeOffsetB = aligned.lapB[0].time;\n    const finalTimeA = lapA[lapA.length - 1].time - timeOffsetA;\n    const finalTimeB = aligned.lapB[lapA.length - 1].time - timeOffsetB;\n    const totalTimeDelta = finalTimeA - finalTimeB;\n\n    const speedDeltas = lapA.map((p, i) => p.speed - aligned.lapB[i].speed);\n    const avgSpeedDelta = this.average(speedDeltas);\n    const maxSpeedDelta = Math.max(...speedDeltas.map(Math.abs));\n    const maxSpeedDeltaIdx = speedDeltas.findIndex(d => Math.abs(d) === maxSpeedDelta);\n    const maxSpeedDeltaDistance = lapA[maxSpeedDeltaIdx].distance;\n\n    const sortedCorners = [...corners].sort((a, b) => a.timeDelta - b.timeDelta);\n    const fastestCornerGain = sortedCorners[0];\n    const slowestCornerLoss = sortedCorners[sortedCorners.length - 1];\n\n    const sortedZones = [...accelZones].sort((a, b) => a.timeDelta - b.timeDelta);\n    const bestAccelZone = sortedZones[0];\n    const worstAccelZone = sortedZones[sortedZones.length - 1];\n\n    return {\n      totalTimeDelta,\n      totalDistance,\n\n      timeGainedInCorners,\n      timeGainedInAccelZones,\n\n      avgSpeedDelta,\n      maxSpeedDelta,\n      maxSpeedDeltaDistance,\n\n      fastestCornerGain: {\n        cornerNumber: fastestCornerGain?.cornerNumber ?? 0,\n        timeDelta: fastestCornerGain?.timeDelta ?? 0\n      },\n      slowestCornerLoss: {\n        cornerNumber: slowestCornerLoss?.cornerNumber ?? 0,\n        timeDelta: slowestCornerLoss?.timeDelta ?? 0\n      },\n\n      bestAccelZone: {\n        zoneIndex: bestAccelZone ? accelZones.indexOf(bestAccelZone) : 0,\n        timeDelta: bestAccelZone?.timeDelta ?? 0\n      },\n      worstAccelZone: {\n        zoneIndex: worstAccelZone ? accelZones.indexOf(worstAccelZone) : 0,\n        timeDelta: worstAccelZone?.timeDelta ?? 0\n      },\n    };\n  }\n\n  private findPointAtDistance(\n    points: NormalizedTelemetryPoint[],\n    distance: number,\n    tolerance: number = 5\n  ): NormalizedTelemetryPoint {\n    const closest = points.reduce((best, current) => {\n      const bestDist = Math.abs(best.distance - distance);\n      const currentDist = Math.abs(current.distance - distance);\n      return currentDist < bestDist ? current : best;\n    });\n\n    if (Math.abs(closest.distance - distance) > tolerance) {\n      console.warn(`Point at distance ${distance}m not found within ${tolerance}m tolerance`);\n    }\n\n    return closest;\n  }\n\n  private getPointsInRange(\n    points: NormalizedTelemetryPoint[],\n    startDistance: number,\n    endDistance: number\n  ): NormalizedTelemetryPoint[] {\n    return points.filter(p => p.distance >= startDistance && p.distance <= endDistance);\n  }\n\n  private average(values: number[]): number {\n    if (values.length === 0) return 0;\n    return values.reduce((sum, v) => sum + v, 0) / values.length;\n  }\n\n  formatTimeDelta(seconds: number): string {\n    const sign = seconds >= 0 ? '+' : '';\n    return `${sign}${seconds.toFixed(3)}s`;\n  }\n\n  getDeltaColor(delta: number): 'green' | 'red' | 'neutral' {\n    if (delta < -0.01) return 'green';\n    if (delta > 0.01) return 'red';\n    return 'neutral';\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 565, "column": 0}, "map": {"version":3,"sources":["file:///Users/haseebulhaqmalik/Desktop/lap-lens/src/analysis/sector-analysis.ts"],"sourcesContent":["import { NormalizedTelemetryPoint } from '../types/f1-2024-packets';\nimport { AlignedLaps } from './lap-aligner';\nimport { CornerDatabase } from './corner-database';\n\nexport interface SectorBoundary {\n  sectorNumber: number;\n  startDistance: number;\n  endDistance: number;\n}\n\nexport interface SectorTime {\n  sectorNumber: number;\n  startDistance: number;\n  endDistance: number;\n  distance: number;\n  time: number;\n  avgSpeed: number;\n  minSpeed: number;\n  maxSpeed: number;\n  avgThrottle: number;\n  avgBrake: number;\n  cornerCount: number;\n}\n\nexport interface SectorComparison {\n  sectorNumber: number;\n  startDistance: number;\n  endDistance: number;\n  distance: number;\n\n  lapA: SectorTime;\n  lapB: SectorTime;\n\n  timeDelta: number;\n  avgSpeedDelta: number;\n\n  timeGainPercentage: number;\n}\n\nexport interface SectorAnalysis {\n  sectors: SectorComparison[];\n  summary: {\n    totalTimeDelta: number;\n    fastestSector: { sectorNumber: number; timeDelta: number };\n    slowestSector: { sectorNumber: number; timeDelta: number };\n  };\n}\n\nexport interface SectorConfig {\n  trackName: string;\n  sectors: SectorBoundary[];\n}\n\nexport class SectorAnalyzer {\n  private cornerDb: CornerDatabase;\n  private sectorConfigs: Map<string, SectorBoundary[]>;\n\n  constructor() {\n    this.cornerDb = new CornerDatabase();\n    this.sectorConfigs = new Map();\n    this.initializeDefaultConfigs();\n  }\n\n  private initializeDefaultConfigs(): void {\n    this.sectorConfigs.set('bahrain', [\n      { sectorNumber: 1, startDistance: 0, endDistance: 1900 },\n      { sectorNumber: 2, startDistance: 1900, endDistance: 3700 },\n      { sectorNumber: 3, startDistance: 3700, endDistance: 999999 },\n    ]);\n  }\n\n  analyzeSectors(\n    aligned: AlignedLaps,\n    trackName: string,\n    trackId?: number\n  ): SectorAnalysis {\n    const boundaries = this.getSectorBoundaries(trackName, aligned.lapA);\n    const sectors: SectorComparison[] = [];\n\n    for (const boundary of boundaries) {\n      const sectorA = this.calculateSectorTime(aligned.lapA, boundary, trackName, trackId);\n      const sectorB = this.calculateSectorTime(aligned.lapB, boundary, trackName, trackId);\n\n      const timeDelta = sectorA.time - sectorB.time;\n      const avgSpeedDelta = sectorA.avgSpeed - sectorB.avgSpeed;\n      const timeGainPercentage = sectorB.time > 0 ? (timeDelta / sectorB.time) * 100 : 0;\n\n      sectors.push({\n        sectorNumber: boundary.sectorNumber,\n        startDistance: boundary.startDistance,\n        endDistance: Math.min(boundary.endDistance, aligned.endDistance),\n        distance: sectorA.distance,\n        lapA: sectorA,\n        lapB: sectorB,\n        timeDelta,\n        avgSpeedDelta,\n        timeGainPercentage,\n      });\n    }\n\n    const sortedSectors = [...sectors].sort((a, b) => a.timeDelta - b.timeDelta);\n    const fastestSector = sortedSectors[0];\n    const slowestSector = sortedSectors[sortedSectors.length - 1];\n\n    const totalTimeDelta = sectors.reduce((sum, s) => sum + s.timeDelta, 0);\n\n    return {\n      sectors,\n      summary: {\n        totalTimeDelta,\n        fastestSector: {\n          sectorNumber: fastestSector?.sectorNumber ?? 0,\n          timeDelta: fastestSector?.timeDelta ?? 0,\n        },\n        slowestSector: {\n          sectorNumber: slowestSector?.sectorNumber ?? 0,\n          timeDelta: slowestSector?.timeDelta ?? 0,\n        },\n      },\n    };\n  }\n\n  private getSectorBoundaries(\n    trackName: string,\n    lap: NormalizedTelemetryPoint[]\n  ): SectorBoundary[] {\n    const sanitizedName = this.sanitizeTrackName(trackName);\n    const configured = this.sectorConfigs.get(sanitizedName);\n\n    if (configured) {\n      return configured;\n    }\n\n    return this.autoDetectSectors(lap);\n  }\n\n  private autoDetectSectors(lap: NormalizedTelemetryPoint[]): SectorBoundary[] {\n    if (lap.length === 0) {\n      return [];\n    }\n\n    const trackLength = lap[lap.length - 1].distance - lap[0].distance;\n    const sectorLength = trackLength / 3;\n\n    return [\n      {\n        sectorNumber: 1,\n        startDistance: lap[0].distance,\n        endDistance: lap[0].distance + sectorLength,\n      },\n      {\n        sectorNumber: 2,\n        startDistance: lap[0].distance + sectorLength,\n        endDistance: lap[0].distance + sectorLength * 2,\n      },\n      {\n        sectorNumber: 3,\n        startDistance: lap[0].distance + sectorLength * 2,\n        endDistance: lap[lap.length - 1].distance,\n      },\n    ];\n  }\n\n  private calculateSectorTime(\n    lap: NormalizedTelemetryPoint[],\n    boundary: SectorBoundary,\n    trackName: string,\n    trackId?: number\n  ): SectorTime {\n    const sectorPoints = lap.filter(\n      p => p.distance >= boundary.startDistance && p.distance <= boundary.endDistance\n    );\n\n    if (sectorPoints.length === 0) {\n      return {\n        sectorNumber: boundary.sectorNumber,\n        startDistance: boundary.startDistance,\n        endDistance: boundary.endDistance,\n        distance: 0,\n        time: 0,\n        avgSpeed: 0,\n        minSpeed: 0,\n        maxSpeed: 0,\n        avgThrottle: 0,\n        avgBrake: 0,\n        cornerCount: 0,\n      };\n    }\n\n    const startTime = sectorPoints[0].time;\n    const endTime = sectorPoints[sectorPoints.length - 1].time;\n    const time = endTime - startTime;\n\n    const distance = sectorPoints[sectorPoints.length - 1].distance - sectorPoints[0].distance;\n\n    const speeds = sectorPoints.map(p => p.speed);\n    const avgSpeed = this.average(speeds);\n    const minSpeed = Math.min(...speeds);\n    const maxSpeed = Math.max(...speeds);\n\n    const avgThrottle = this.average(sectorPoints.map(p => p.throttle));\n    const avgBrake = this.average(sectorPoints.map(p => p.brake));\n\n    const cornerCount = this.countCornersInSector(\n      trackName,\n      trackId,\n      boundary.startDistance,\n      boundary.endDistance\n    );\n\n    return {\n      sectorNumber: boundary.sectorNumber,\n      startDistance: boundary.startDistance,\n      endDistance: boundary.endDistance,\n      distance,\n      time,\n      avgSpeed,\n      minSpeed,\n      maxSpeed,\n      avgThrottle,\n      avgBrake,\n      cornerCount,\n    };\n  }\n\n  private countCornersInSector(\n    trackName: string,\n    trackId: number | undefined,\n    startDistance: number,\n    endDistance: number\n  ): number {\n    const trackData = this.cornerDb.loadTrackCorners(trackName, trackId);\n\n    if (!trackData) {\n      return 0;\n    }\n\n    return trackData.corners.filter(\n      c => c.apexDistance >= startDistance && c.apexDistance <= endDistance\n    ).length;\n  }\n\n  private average(values: number[]): number {\n    if (values.length === 0) return 0;\n    return values.reduce((sum, v) => sum + v, 0) / values.length;\n  }\n\n  private sanitizeTrackName(trackName: string): string {\n    const match = trackName.match(/\\(([^)]+)\\)/);\n    const baseName = match ? match[1] : trackName;\n\n    return baseName\n      .toLowerCase()\n      .trim()\n      .replace(/\\s+/g, '-')\n      .replace(/[^a-z0-9-]/g, '');\n  }\n\n  addSectorConfig(config: SectorConfig): void {\n    const sanitizedName = this.sanitizeTrackName(config.trackName);\n    this.sectorConfigs.set(sanitizedName, config.sectors);\n  }\n\n  formatTimeDelta(seconds: number): string {\n    const sign = seconds >= 0 ? '+' : '';\n    return `${sign}${seconds.toFixed(3)}s`;\n  }\n\n  getDeltaColor(delta: number): 'green' | 'red' | 'neutral' {\n    if (delta < -0.01) return 'green';\n    if (delta > 0.01) return 'red';\n    return 'neutral';\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 748, "column": 0}, "map": {"version":3,"sources":["file:///Users/haseebulhaqmalik/Desktop/lap-lens/src/analysis/gforce-analysis.ts"],"sourcesContent":["import { NormalizedTelemetryPoint } from '../types/f1-2024-packets';\nimport { AlignedLaps } from './lap-aligner';\nimport { CornerDatabase, CornerDatabaseEntry } from './corner-database';\n\nexport interface GForcePoint {\n  distance: number;\n  lateralG: number;\n  longitudinalG: number;\n  combinedG: number;\n  speed: number;\n  heading?: number;\n}\n\nexport interface GForceComparison {\n  distance: number;\n  lapA: GForcePoint;\n  lapB: GForcePoint;\n  lateralGDelta: number;\n  longitudinalGDelta: number;\n  combinedGDelta: number;\n}\n\nexport interface CornerGForceAnalysis {\n  cornerNumber: number;\n  cornerName?: string;\n  entryDistance: number;\n  apexDistance: number;\n  exitDistance: number;\n\n  peakLateralG: { lapA: number; lapB: number; delta: number };\n  avgLateralG: { lapA: number; lapB: number; delta: number };\n  peakLateralGDistance: { lapA: number; lapB: number };\n\n  peakBrakingG: { lapA: number; lapB: number; delta: number };\n  avgBrakingG: { lapA: number; lapB: number; delta: number };\n  peakAccelG: { lapA: number; lapB: number; delta: number };\n  avgAccelG: { lapA: number; lapB: number; delta: number };\n\n  peakCombinedG: { lapA: number; lapB: number; delta: number };\n\n  lateralGStdDev: { lapA: number; lapB: number };\n  longitudinalGStdDev: { lapA: number; lapB: number };\n\n  entrySpeed: { lapA: number; lapB: number; delta: number };\n  apexSpeed: { lapA: number; lapB: number; delta: number };\n  exitSpeed: { lapA: number; lapB: number; delta: number };\n  minSpeed: { lapA: number; lapB: number; delta: number };\n\n  insight?: CornerInsight;\n}\n\nexport interface CornerInsight {\n  type: 'under-braking' | 'over-braking' | 'not-using-grip' | 'better-previous-corner' | 'good-adaptation' | 'slower-overall' | 'faster-overall' | 'neutral';\n  confidence: 'high' | 'medium' | 'low';\n  message: string;\n  recommendation?: string;\n}\n\nexport interface FrictionCircleData {\n  points: Array<{ lateral: number; longitudinal: number }>;\n  maxRadius: number;\n}\n\nexport interface GForceAnalysis {\n  corners: CornerGForceAnalysis[];\n  frictionCircle: {\n    lapA: FrictionCircleData;\n    lapB: FrictionCircleData;\n  };\n  summary: {\n    peakLateralG: { lapA: number; lapB: number; delta: number };\n    avgLateralG: { lapA: number; lapB: number; delta: number };\n    peakBrakingG: { lapA: number; lapB: number; delta: number };\n    avgBrakingG: { lapA: number; lapB: number; delta: number };\n    peakAccelG: { lapA: number; lapB: number; delta: number };\n    avgAccelG: { lapA: number; lapB: number; delta: number };\n    bestCornerLateralG: { cornerNumber: number; lateralG: number };\n    worstCornerLateralG: { cornerNumber: number; lateralG: number };\n  };\n}\n\nexport interface GForceConfig {\n  smoothingWindow: number;\n  minGForceThreshold: number;\n}\n\nexport class GForceAnalyzer {\n  private config: GForceConfig;\n  private cornerDb: CornerDatabase;\n\n  constructor(config: Partial<GForceConfig> = {}) {\n    this.config = {\n      smoothingWindow: config.smoothingWindow ?? 3,\n      minGForceThreshold: config.minGForceThreshold ?? 0.01,\n    };\n    this.cornerDb = new CornerDatabase();\n  }\n\n  analyzeGForces(\n    aligned: AlignedLaps,\n    trackName: string,\n    trackId?: number\n  ): GForceAnalysis {\n    const gforcesA = this.calculateGForces(aligned.lapA);\n    const gforcesB = this.calculateGForces(aligned.lapB);\n\n    const corners = this.analyzeCorners(gforcesA, gforcesB, trackName, trackId);\n    const frictionCircle = {\n      lapA: this.calculateFrictionCircle(gforcesA),\n      lapB: this.calculateFrictionCircle(gforcesB),\n    };\n    const summary = this.calculateSummary(gforcesA, gforcesB, corners);\n\n    return {\n      corners,\n      frictionCircle,\n      summary,\n    };\n  }\n\n  private calculateGForces(lap: NormalizedTelemetryPoint[]): GForcePoint[] {\n    return lap.map(point => {\n      const lateralG = Math.abs(point.gLat);\n      const longitudinalG = point.gLong;\n      const combinedG = Math.sqrt(lateralG ** 2 + longitudinalG ** 2);\n      const heading = this.calculateHeading(lap, lap.indexOf(point));\n\n      return {\n        distance: point.distance,\n        lateralG,\n        longitudinalG,\n        combinedG,\n        speed: point.speed,\n        heading,\n      };\n    });\n  }\n\n  private calculateHeading(lap: NormalizedTelemetryPoint[], index: number): number | undefined {\n    if (index === 0) return undefined;\n\n    const current = lap[index];\n    const previous = lap[index - 1];\n\n    const dx = current.x - previous.x;\n    const dy = current.y - previous.y;\n\n    return Math.atan2(dy, dx);\n  }\n\n  private analyzeCorners(\n    gforcesA: GForcePoint[],\n    gforcesB: GForcePoint[],\n    trackName: string,\n    trackId?: number\n  ): CornerGForceAnalysis[] {\n    const trackData = this.cornerDb.loadTrackCorners(trackName, trackId);\n\n    if (!trackData) {\n      throw new Error(`No corner database found for track: ${trackName}`);\n    }\n\n    const analyses: CornerGForceAnalysis[] = [];\n\n    for (const corner of trackData.corners) {\n      const analysis = this.analyzeCorner(gforcesA, gforcesB, corner);\n      analyses.push(analysis);\n    }\n\n    return analyses;\n  }\n\n  private analyzeCorner(\n    gforcesA: GForcePoint[],\n    gforcesB: GForcePoint[],\n    corner: CornerDatabaseEntry\n  ): CornerGForceAnalysis {\n    const cornerGforcesA = this.getGForcesInRange(gforcesA, corner.entryDistance, corner.exitDistance);\n    const cornerGforcesB = this.getGForcesInRange(gforcesB, corner.entryDistance, corner.exitDistance);\n\n    const entryA = this.findPointAtDistance(gforcesA, corner.entryDistance);\n    const entryB = this.findPointAtDistance(gforcesB, corner.entryDistance);\n    const apexA = this.findPointAtDistance(gforcesA, corner.apexDistance);\n    const apexB = this.findPointAtDistance(gforcesB, corner.apexDistance);\n    const exitA = this.findPointAtDistance(gforcesA, corner.exitDistance);\n    const exitB = this.findPointAtDistance(gforcesB, corner.exitDistance);\n\n    const lateralGsA = cornerGforcesA.map(g => g.lateralG);\n    const lateralGsB = cornerGforcesB.map(g => g.lateralG);\n\n    const peakLateralGA = Math.max(...lateralGsA);\n    const peakLateralGB = Math.max(...lateralGsB);\n    const avgLateralGA = this.average(lateralGsA);\n    const avgLateralGB = this.average(lateralGsB);\n\n    const peakLateralGDistanceA = cornerGforcesA.find(g => g.lateralG === peakLateralGA)?.distance ?? corner.apexDistance;\n    const peakLateralGDistanceB = cornerGforcesB.find(g => g.lateralG === peakLateralGB)?.distance ?? corner.apexDistance;\n\n    const brakingGsA = cornerGforcesA.map(g => g.longitudinalG).filter(g => g < -this.config.minGForceThreshold);\n    const brakingGsB = cornerGforcesB.map(g => g.longitudinalG).filter(g => g < -this.config.minGForceThreshold);\n    const accelGsA = cornerGforcesA.map(g => g.longitudinalG).filter(g => g > this.config.minGForceThreshold);\n    const accelGsB = cornerGforcesB.map(g => g.longitudinalG).filter(g => g > this.config.minGForceThreshold);\n\n    const peakBrakingGA = brakingGsA.length > 0 ? Math.min(...brakingGsA) : 0;\n    const peakBrakingGB = brakingGsB.length > 0 ? Math.min(...brakingGsB) : 0;\n    const avgBrakingGA = brakingGsA.length > 0 ? this.average(brakingGsA) : 0;\n    const avgBrakingGB = brakingGsB.length > 0 ? this.average(brakingGsB) : 0;\n\n    const peakAccelGA = accelGsA.length > 0 ? Math.max(...accelGsA) : 0;\n    const peakAccelGB = accelGsB.length > 0 ? Math.max(...accelGsB) : 0;\n    const avgAccelGA = accelGsA.length > 0 ? this.average(accelGsA) : 0;\n    const avgAccelGB = accelGsB.length > 0 ? this.average(accelGsB) : 0;\n\n    const combinedGsA = cornerGforcesA.map(g => g.combinedG);\n    const combinedGsB = cornerGforcesB.map(g => g.combinedG);\n    const peakCombinedGA = Math.max(...combinedGsA);\n    const peakCombinedGB = Math.max(...combinedGsB);\n\n    const lateralGStdDevA = this.stdDev(lateralGsA);\n    const lateralGStdDevB = this.stdDev(lateralGsB);\n    const longitudinalGStdDevA = this.stdDev(cornerGforcesA.map(g => g.longitudinalG));\n    const longitudinalGStdDevB = this.stdDev(cornerGforcesB.map(g => g.longitudinalG));\n\n    const minSpeedA = Math.min(...cornerGforcesA.map(g => g.speed));\n    const minSpeedB = Math.min(...cornerGforcesB.map(g => g.speed));\n\n    const analysis: CornerGForceAnalysis = {\n      cornerNumber: corner.number,\n      cornerName: corner.name,\n      entryDistance: corner.entryDistance,\n      apexDistance: corner.apexDistance,\n      exitDistance: corner.exitDistance,\n\n      peakLateralG: { lapA: peakLateralGA, lapB: peakLateralGB, delta: peakLateralGA - peakLateralGB },\n      avgLateralG: { lapA: avgLateralGA, lapB: avgLateralGB, delta: avgLateralGA - avgLateralGB },\n      peakLateralGDistance: { lapA: peakLateralGDistanceA, lapB: peakLateralGDistanceB },\n\n      peakBrakingG: { lapA: peakBrakingGA, lapB: peakBrakingGB, delta: peakBrakingGA - peakBrakingGB },\n      avgBrakingG: { lapA: avgBrakingGA, lapB: avgBrakingGB, delta: avgBrakingGA - avgBrakingGB },\n      peakAccelG: { lapA: peakAccelGA, lapB: peakAccelGB, delta: peakAccelGA - peakAccelGB },\n      avgAccelG: { lapA: avgAccelGA, lapB: avgAccelGB, delta: avgAccelGA - avgAccelGB },\n\n      peakCombinedG: { lapA: peakCombinedGA, lapB: peakCombinedGB, delta: peakCombinedGA - peakCombinedGB },\n\n      lateralGStdDev: { lapA: lateralGStdDevA, lapB: lateralGStdDevB },\n      longitudinalGStdDev: { lapA: longitudinalGStdDevA, lapB: longitudinalGStdDevB },\n\n      entrySpeed: { lapA: entryA.speed, lapB: entryB.speed, delta: entryA.speed - entryB.speed },\n      apexSpeed: { lapA: apexA.speed, lapB: apexB.speed, delta: apexA.speed - apexB.speed },\n      exitSpeed: { lapA: exitA.speed, lapB: exitB.speed, delta: exitA.speed - exitB.speed },\n      minSpeed: { lapA: minSpeedA, lapB: minSpeedB, delta: minSpeedA - minSpeedB },\n    };\n\n    analysis.insight = this.generateInsight(analysis);\n\n    return analysis;\n  }\n\n  private calculateFrictionCircle(gforces: GForcePoint[]): FrictionCircleData {\n    const points = gforces.map(g => ({\n      lateral: g.lateralG,\n      longitudinal: g.longitudinalG,\n    }));\n\n    const maxRadius = Math.max(...gforces.map(g => g.combinedG));\n\n    return { points, maxRadius };\n  }\n\n  private calculateSummary(\n    gforcesA: GForcePoint[],\n    gforcesB: GForcePoint[],\n    corners: CornerGForceAnalysis[]\n  ) {\n    const lateralGsA = gforcesA.map(g => g.lateralG);\n    const lateralGsB = gforcesB.map(g => g.lateralG);\n\n    const peakLateralGA = Math.max(...lateralGsA);\n    const peakLateralGB = Math.max(...lateralGsB);\n    const avgLateralGA = this.average(lateralGsA);\n    const avgLateralGB = this.average(lateralGsB);\n\n    const brakingGsA = gforcesA.map(g => g.longitudinalG).filter(g => g < -this.config.minGForceThreshold);\n    const brakingGsB = gforcesB.map(g => g.longitudinalG).filter(g => g < -this.config.minGForceThreshold);\n    const accelGsA = gforcesA.map(g => g.longitudinalG).filter(g => g > this.config.minGForceThreshold);\n    const accelGsB = gforcesB.map(g => g.longitudinalG).filter(g => g > this.config.minGForceThreshold);\n\n    const peakBrakingGA = brakingGsA.length > 0 ? Math.min(...brakingGsA) : 0;\n    const peakBrakingGB = brakingGsB.length > 0 ? Math.min(...brakingGsB) : 0;\n    const avgBrakingGA = brakingGsA.length > 0 ? this.average(brakingGsA) : 0;\n    const avgBrakingGB = brakingGsB.length > 0 ? this.average(brakingGsB) : 0;\n\n    const peakAccelGA = accelGsA.length > 0 ? Math.max(...accelGsA) : 0;\n    const peakAccelGB = accelGsB.length > 0 ? Math.max(...accelGsB) : 0;\n    const avgAccelGA = accelGsA.length > 0 ? this.average(accelGsA) : 0;\n    const avgAccelGB = accelGsB.length > 0 ? this.average(accelGsB) : 0;\n\n    const sortedCorners = [...corners].sort((a, b) => b.avgLateralG.lapA - a.avgLateralG.lapA);\n    const bestCorner = sortedCorners[0];\n    const worstCorner = sortedCorners[sortedCorners.length - 1];\n\n    return {\n      peakLateralG: { lapA: peakLateralGA, lapB: peakLateralGB, delta: peakLateralGA - peakLateralGB },\n      avgLateralG: { lapA: avgLateralGA, lapB: avgLateralGB, delta: avgLateralGA - avgLateralGB },\n      peakBrakingG: { lapA: peakBrakingGA, lapB: peakBrakingGB, delta: peakBrakingGA - peakBrakingGB },\n      avgBrakingG: { lapA: avgBrakingGA, lapB: avgBrakingGB, delta: avgBrakingGA - avgBrakingGB },\n      peakAccelG: { lapA: peakAccelGA, lapB: peakAccelGB, delta: peakAccelGA - peakAccelGB },\n      avgAccelG: { lapA: avgAccelGA, lapB: avgAccelGB, delta: avgAccelGA - avgAccelGB },\n      bestCornerLateralG: {\n        cornerNumber: bestCorner?.cornerNumber ?? 0,\n        lateralG: bestCorner?.avgLateralG.lapA ?? 0,\n      },\n      worstCornerLateralG: {\n        cornerNumber: worstCorner?.cornerNumber ?? 0,\n        lateralG: worstCorner?.avgLateralG.lapA ?? 0,\n      },\n    };\n  }\n\n  private generateInsight(corner: CornerGForceAnalysis): CornerInsight {\n    const entrySpeedSimilar = Math.abs(corner.entrySpeed.delta) < 10;\n    const largeLateralGDiff = Math.abs(corner.avgLateralG.delta) > 0.5;\n    const largeBrakingGDiff = Math.abs(corner.peakBrakingG.delta) > 1.0;\n    const largeEntrySpeedDiff = Math.abs(corner.entrySpeed.delta) > 20;\n    const apexSpeedDelta = corner.apexSpeed.delta;\n    const exitSpeedDelta = corner.exitSpeed.delta;\n\n    if (entrySpeedSimilar && corner.peakBrakingG.delta > 1.0 && apexSpeedDelta < -10 && exitSpeedDelta < -10) {\n      return {\n        type: 'under-braking',\n        confidence: 'high',\n        message: `Same entry speed but weaker braking (${corner.peakBrakingG.delta.toFixed(1)}G) led to slower apex/exit`,\n        recommendation: 'Brake harder - you have more grip available'\n      };\n    }\n\n    if (entrySpeedSimilar && corner.peakBrakingG.delta < -1.0 && apexSpeedDelta < -5) {\n      return {\n        type: 'over-braking',\n        confidence: 'medium',\n        message: `Braked harder but still slower apex - may be scrubbing too much speed`,\n        recommendation: 'Try lighter braking or different line'\n      };\n    }\n\n    if (largeLateralGDiff && corner.avgLateralG.delta < -0.5) {\n      return {\n        type: 'not-using-grip',\n        confidence: 'high',\n        message: `Significantly lower lateral G (${corner.avgLateralG.delta.toFixed(1)}G) - not using available grip`,\n        recommendation: 'Push harder through this corner - carry more speed'\n      };\n    }\n\n    if (largeEntrySpeedDiff && corner.entrySpeed.delta > 20 && Math.abs(corner.apexSpeed.delta) < 10) {\n      return {\n        type: 'better-previous-corner',\n        confidence: 'medium',\n        message: `Entered ${corner.entrySpeed.delta.toFixed(0)} km/h faster from better previous corner/straight`,\n        recommendation: 'Good exit from previous section - adapted well'\n      };\n    }\n\n    if (largeLateralGDiff && corner.avgLateralG.delta > 0.5 && apexSpeedDelta > 5 && exitSpeedDelta > 5) {\n      return {\n        type: 'faster-overall',\n        confidence: 'high',\n        message: `Higher lateral G (+${corner.avgLateralG.delta.toFixed(1)}G) with faster speeds throughout`,\n        recommendation: 'Excellent corner - using more grip effectively'\n      };\n    }\n\n    if (apexSpeedDelta < -15 && exitSpeedDelta < -15) {\n      return {\n        type: 'slower-overall',\n        confidence: 'medium',\n        message: `Slower apex and exit - check braking point and throttle application`,\n        recommendation: 'Analyze full corner trace - multiple factors at play'\n      };\n    }\n\n    return {\n      type: 'neutral',\n      confidence: 'low',\n      message: 'Similar performance - small variations',\n    };\n  }\n\n  private findPointAtDistance(gforces: GForcePoint[], distance: number): GForcePoint {\n    return gforces.reduce((closest, current) => {\n      const closestDist = Math.abs(closest.distance - distance);\n      const currentDist = Math.abs(current.distance - distance);\n      return currentDist < closestDist ? current : closest;\n    });\n  }\n\n  private getGForcesInRange(gforces: GForcePoint[], start: number, end: number): GForcePoint[] {\n    return gforces.filter(g => g.distance >= start && g.distance <= end);\n  }\n\n  private average(values: number[]): number {\n    if (values.length === 0) return 0;\n    return values.reduce((sum, v) => sum + v, 0) / values.length;\n  }\n\n  private stdDev(values: number[]): number {\n    if (values.length === 0) return 0;\n    const avg = this.average(values);\n    const squareDiffs = values.map(v => (v - avg) ** 2);\n    const avgSquareDiff = this.average(squareDiffs);\n    return Math.sqrt(avgSquareDiff);\n  }\n\n  formatG(g: number): string {\n    return `${g.toFixed(2)}G`;\n  }\n\n  getDeltaColor(delta: number): 'green' | 'red' | 'neutral' {\n    if (delta > 0.05) return 'green';\n    if (delta < -0.05) return 'red';\n    return 'neutral';\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1102, "column": 0}, "map": {"version":3,"sources":["file:///Users/haseebulhaqmalik/Desktop/lap-lens/src/analysis/lap-loader.ts"],"sourcesContent":["import * as fs from 'fs';\nimport * as path from 'path';\nimport { NormalizedTelemetryPoint } from '../types/f1-2024-packets';\n\nexport interface LapInfo {\n  filePath: string;\n  lapNumber: number;\n  timestamp: string;\n  pointCount: number;\n}\n\nexport class LapLoader {\n  private lapsDir: string;\n\n  constructor(lapsDir: string = './laps') {\n    this.lapsDir = lapsDir;\n  }\n\n  listAvailableLaps(): LapInfo[] {\n    if (!fs.existsSync(this.lapsDir)) {\n      return [];\n    }\n\n    const files = fs.readdirSync(this.lapsDir)\n      .filter(f => f.endsWith('.json'))\n      .map(f => {\n        const jsonPath = path.join(this.lapsDir, f);\n        const metadata = JSON.parse(fs.readFileSync(jsonPath, 'utf-8'));\n        return {\n          filePath: jsonPath.replace('.json', '.csv'),\n          lapNumber: metadata.lapNumber,\n          timestamp: metadata.timestamp,\n          pointCount: metadata.pointCount,\n        };\n      })\n      .sort((a, b) => a.lapNumber - b.lapNumber);\n\n    return files;\n  }\n\n  loadLap(csvPath: string): NormalizedTelemetryPoint[] {\n    const content = fs.readFileSync(csvPath, 'utf-8');\n    const lines = content.split('\\n').slice(1);\n\n    const points: NormalizedTelemetryPoint[] = [];\n\n    for (const line of lines) {\n      if (!line.trim()) continue;\n\n      const parts = line.split(',').map(p => parseFloat(p));\n      if (parts.length < 11) continue;\n\n      points.push({\n        time: parts[0],\n        distance: parts[1],\n        x: parts[2],\n        y: parts[3],\n        speed: parts[4],\n        throttle: parts[5],\n        brake: parts[6],\n        steering: parts[7],\n        gear: parts[8],\n        gLat: parts[9],\n        gLong: parts[10],\n        yaw: parts[11] || 0, // Backwards compatibility for old laps\n        lapNum: 0,\n      });\n    }\n\n    return points;\n  }\n\n  loadLapByNumber(lapNumber: number): NormalizedTelemetryPoint[] | null {\n    const laps = this.listAvailableLaps();\n    const lap = laps.find(l => l.lapNumber === lapNumber);\n\n    if (!lap) {\n      return null;\n    }\n\n    return this.loadLap(lap.filePath);\n  }\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AAUO,MAAM;IACH,QAAgB;IAExB,YAAY,UAAkB,QAAQ,CAAE;QACtC,IAAI,CAAC,OAAO,GAAG;IACjB;IAEA,oBAA+B;QAC7B,IAAI,CAAC,2GAAa,CAAC,IAAI,CAAC,OAAO,GAAG;YAChC,OAAO,EAAE;QACX;QAEA,MAAM,QAAQ,4GAAc,CAAC,IAAI,CAAC,OAAO,EACtC,MAAM,CAAC,CAAA,IAAK,EAAE,QAAQ,CAAC,UACvB,GAAG,CAAC,CAAA;YACH,MAAM,WAAW,yGAAS,CAAC,IAAI,CAAC,OAAO,EAAE;YACzC,MAAM,WAAW,KAAK,KAAK,CAAC,6GAAe,CAAC,UAAU;YACtD,OAAO;gBACL,UAAU,SAAS,OAAO,CAAC,SAAS;gBACpC,WAAW,SAAS,SAAS;gBAC7B,WAAW,SAAS,SAAS;gBAC7B,YAAY,SAAS,UAAU;YACjC;QACF,GACC,IAAI,CAAC,CAAC,GAAG,IAAM,EAAE,SAAS,GAAG,EAAE,SAAS;QAE3C,OAAO;IACT;IAEA,QAAQ,OAAe,EAA8B;QACnD,MAAM,UAAU,6GAAe,CAAC,SAAS;QACzC,MAAM,QAAQ,QAAQ,KAAK,CAAC,MAAM,KAAK,CAAC;QAExC,MAAM,SAAqC,EAAE;QAE7C,KAAK,MAAM,QAAQ,MAAO;YACxB,IAAI,CAAC,KAAK,IAAI,IAAI;YAElB,MAAM,QAAQ,KAAK,KAAK,CAAC,KAAK,GAAG,CAAC,CAAA,IAAK,WAAW;YAClD,IAAI,MAAM,MAAM,GAAG,IAAI;YAEvB,OAAO,IAAI,CAAC;gBACV,MAAM,KAAK,CAAC,EAAE;gBACd,UAAU,KAAK,CAAC,EAAE;gBAClB,GAAG,KAAK,CAAC,EAAE;gBACX,GAAG,KAAK,CAAC,EAAE;gBACX,OAAO,KAAK,CAAC,EAAE;gBACf,UAAU,KAAK,CAAC,EAAE;gBAClB,OAAO,KAAK,CAAC,EAAE;gBACf,UAAU,KAAK,CAAC,EAAE;gBAClB,MAAM,KAAK,CAAC,EAAE;gBACd,MAAM,KAAK,CAAC,EAAE;gBACd,OAAO,KAAK,CAAC,GAAG;gBAChB,KAAK,KAAK,CAAC,GAAG,IAAI;gBAClB,QAAQ;YACV;QACF;QAEA,OAAO;IACT;IAEA,gBAAgB,SAAiB,EAAqC;QACpE,MAAM,OAAO,IAAI,CAAC,iBAAiB;QACnC,MAAM,MAAM,KAAK,IAAI,CAAC,CAAA,IAAK,EAAE,SAAS,KAAK;QAE3C,IAAI,CAAC,KAAK;YACR,OAAO;QACT;QAEA,OAAO,IAAI,CAAC,OAAO,CAAC,IAAI,QAAQ;IAClC;AACF"}},
    {"offset": {"line": 1170, "column": 0}, "map": {"version":3,"sources":["file:///Users/haseebulhaqmalik/Desktop/lap-lens/src/analysis/lap-aligner.ts"],"sourcesContent":["import { NormalizedTelemetryPoint } from '../types/f1-2024-packets';\n\nexport interface AlignedLaps {\n  lapA: NormalizedTelemetryPoint[];\n  lapB: NormalizedTelemetryPoint[];\n  startDistance: number;\n  endDistance: number;\n  length: number;\n}\n\nexport class LapAligner {\n  alignLaps(\n    lapA: NormalizedTelemetryPoint[],\n    lapB: NormalizedTelemetryPoint[]\n  ): AlignedLaps {\n    if (lapA.length === 0 || lapB.length === 0) {\n      throw new Error('Cannot align empty laps');\n    }\n\n    const startA = lapA[0].distance;\n    const endA = lapA[lapA.length - 1].distance;\n\n    const startB = lapB[0].distance;\n    const endB = lapB[lapB.length - 1].distance;\n\n    const startDistance = Math.max(startA, startB);\n    const endDistance = Math.min(endA, endB);\n\n    if (endDistance <= startDistance) {\n      throw new Error('Laps do not overlap');\n    }\n\n    const alignedA = lapA.filter(\n      p => p.distance >= startDistance && p.distance <= endDistance\n    );\n    const alignedB = lapB.filter(\n      p => p.distance >= startDistance && p.distance <= endDistance\n    );\n\n    return {\n      lapA: alignedA,\n      lapB: alignedB,\n      startDistance,\n      endDistance,\n      length: endDistance - startDistance,\n    };\n  }\n\n  trimToSameLength(\n    lapA: NormalizedTelemetryPoint[],\n    lapB: NormalizedTelemetryPoint[]\n  ): AlignedLaps {\n    const minLength = Math.min(lapA.length, lapB.length);\n\n    return {\n      lapA: lapA.slice(0, minLength),\n      lapB: lapB.slice(0, minLength),\n      startDistance: lapA[0].distance,\n      endDistance: lapA[minLength - 1].distance,\n      length: lapA[minLength - 1].distance - lapA[0].distance,\n    };\n  }\n}\n"],"names":[],"mappings":";;;;AAUO,MAAM;IACX,UACE,IAAgC,EAChC,IAAgC,EACnB;QACb,IAAI,KAAK,MAAM,KAAK,KAAK,KAAK,MAAM,KAAK,GAAG;YAC1C,MAAM,IAAI,MAAM;QAClB;QAEA,MAAM,SAAS,IAAI,CAAC,EAAE,CAAC,QAAQ;QAC/B,MAAM,OAAO,IAAI,CAAC,KAAK,MAAM,GAAG,EAAE,CAAC,QAAQ;QAE3C,MAAM,SAAS,IAAI,CAAC,EAAE,CAAC,QAAQ;QAC/B,MAAM,OAAO,IAAI,CAAC,KAAK,MAAM,GAAG,EAAE,CAAC,QAAQ;QAE3C,MAAM,gBAAgB,KAAK,GAAG,CAAC,QAAQ;QACvC,MAAM,cAAc,KAAK,GAAG,CAAC,MAAM;QAEnC,IAAI,eAAe,eAAe;YAChC,MAAM,IAAI,MAAM;QAClB;QAEA,MAAM,WAAW,KAAK,MAAM,CAC1B,CAAA,IAAK,EAAE,QAAQ,IAAI,iBAAiB,EAAE,QAAQ,IAAI;QAEpD,MAAM,WAAW,KAAK,MAAM,CAC1B,CAAA,IAAK,EAAE,QAAQ,IAAI,iBAAiB,EAAE,QAAQ,IAAI;QAGpD,OAAO;YACL,MAAM;YACN,MAAM;YACN;YACA;YACA,QAAQ,cAAc;QACxB;IACF;IAEA,iBACE,IAAgC,EAChC,IAAgC,EACnB;QACb,MAAM,YAAY,KAAK,GAAG,CAAC,KAAK,MAAM,EAAE,KAAK,MAAM;QAEnD,OAAO;YACL,MAAM,KAAK,KAAK,CAAC,GAAG;YACpB,MAAM,KAAK,KAAK,CAAC,GAAG;YACpB,eAAe,IAAI,CAAC,EAAE,CAAC,QAAQ;YAC/B,aAAa,IAAI,CAAC,YAAY,EAAE,CAAC,QAAQ;YACzC,QAAQ,IAAI,CAAC,YAAY,EAAE,CAAC,QAAQ,GAAG,IAAI,CAAC,EAAE,CAAC,QAAQ;QACzD;IACF;AACF"}},
    {"offset": {"line": 1213, "column": 0}, "map": {"version":3,"sources":["file:///Users/haseebulhaqmalik/Desktop/lap-lens/web/app/api/analysis/compare/route.ts"],"sourcesContent":["import { NextResponse } from 'next/server';\nimport path from 'path';\nimport fs from 'fs';\nimport { SpeedComparisonAnalyzer } from '../../../../../src/analysis/speed-comparison';\nimport { SectorAnalyzer } from '../../../../../src/analysis/sector-analysis';\nimport { GForceAnalyzer } from '../../../../../src/analysis/gforce-analysis';\nimport { LapLoader } from '../../../../../src/analysis/lap-loader';\nimport { LapAligner } from '../../../../../src/analysis/lap-aligner';\n\nexport async function GET(request: Request) {\n  try {\n    const { searchParams } = new URL(request.url);\n    const lapA = searchParams.get('lapA');\n    const lapB = searchParams.get('lapB');\n    const type = searchParams.get('type') || 'speed';\n\n    if (!lapA || !lapB) {\n      return NextResponse.json(\n        { error: 'Both lapA and lapB are required' },\n        { status: 400 }\n      );\n    }\n\n    const lapsDir = path.join(process.cwd(), '..', 'laps');\n    const loader = new LapLoader(lapsDir);\n\n    const lapDataA = loader.loadLapByNumber(parseInt(lapA));\n    const lapDataB = loader.loadLapByNumber(parseInt(lapB));\n\n    if (!lapDataA || !lapDataB) {\n      return NextResponse.json(\n        { error: 'Failed to load lap data' },\n        { status: 404 }\n      );\n    }\n\n    // Load metadata\n    const laps = loader.listAvailableLaps();\n    const lapInfoA = laps.find(l => l.lapNumber === parseInt(lapA));\n    const lapInfoB = laps.find(l => l.lapNumber === parseInt(lapB));\n\n    let metadataA = {};\n    let metadataB = {};\n\n    try {\n      if (lapInfoA) {\n        const metadataPath = lapInfoA.filePath.replace('.csv', '.json');\n        metadataA = JSON.parse(fs.readFileSync(metadataPath, 'utf-8'));\n      }\n      if (lapInfoB) {\n        const metadataPath = lapInfoB.filePath.replace('.csv', '.json');\n        metadataB = JSON.parse(fs.readFileSync(metadataPath, 'utf-8'));\n      }\n    } catch (err) {\n      console.error('Failed to load metadata:', err);\n    }\n\n    // Align laps\n    const aligner = new LapAligner();\n    const aligned = aligner.alignLaps(lapDataA, lapDataB);\n\n    // Get track name\n    const trackName = (metadataA as any).trackName || 'bahrain';\n    const match = trackName.match(/\\(([^)]+)\\)/);\n    const simpleName = match ? match[1].toLowerCase() : trackName.toLowerCase();\n\n    let result;\n\n    switch (type) {\n      case 'speed': {\n        const analyzer = new SpeedComparisonAnalyzer();\n        const comparison = analyzer.compareSpeed(aligned, simpleName);\n\n        result = {\n          type: 'speed',\n          comparison,\n          metadata: {\n            lapA: metadataA,\n            lapB: metadataB,\n          },\n        };\n        break;\n      }\n\n      case 'sector': {\n        const analyzer = new SectorAnalyzer();\n        const comparison = analyzer.analyzeSectors(aligned, simpleName);\n\n        result = {\n          type: 'sector',\n          comparison,\n          metadata: {\n            lapA: metadataA,\n            lapB: metadataB,\n          },\n        };\n        break;\n      }\n\n      case 'gforce': {\n        const analyzer = new GForceAnalyzer();\n        const comparison = analyzer.analyzeGForces(aligned, simpleName);\n\n        result = {\n          type: 'gforce',\n          comparison,\n          metadata: {\n            lapA: metadataA,\n            lapB: metadataB,\n          },\n        };\n        break;\n      }\n\n      default:\n        return NextResponse.json(\n          { error: 'Invalid analysis type' },\n          { status: 400 }\n        );\n    }\n\n    return NextResponse.json(result);\n  } catch (error) {\n    console.error('Error in comparison analysis:', error);\n    return NextResponse.json(\n      { error: 'Failed to perform analysis' },\n      { status: 500 }\n    );\n  }\n}\n"],"names":[],"mappings":"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"}}]
}