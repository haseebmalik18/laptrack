{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 58, "column": 0}, "map": {"version":3,"sources":["file:///Users/haseebulhaqmalik/Desktop/lap-lens/web/app/api/boundaries/%5Btrack%5D/route.ts"],"sourcesContent":["import { NextResponse } from 'next/server';\nimport fs from 'fs';\nimport path from 'path';\n\ninterface BoundaryPoint {\n  distance: number;\n  x: number;\n  z: number;\n}\n\ninterface BoundaryFile {\n  trackId: number;\n  trackName: string;\n  side: 'left' | 'right';\n  carWidth: number;\n  pointCount: number;\n  timestamp: string;\n  data: BoundaryPoint[];\n}\n\n// Apply moving average smoothing using sliding window\nfunction smoothBoundary(points: BoundaryPoint[], windowSize: number = 10): BoundaryPoint[] {\n  if (points.length === 0) return points;\n\n  const smoothed: BoundaryPoint[] = [];\n  const halfWindow = Math.floor(windowSize / 2);\n\n  for (let i = 0; i < points.length; i++) {\n    const start = Math.max(0, i - halfWindow);\n    const end = Math.min(points.length, i + halfWindow + 1);\n\n    let sumX = 0;\n    let sumZ = 0;\n    let count = 0;\n\n    for (let j = start; j < end; j++) {\n      sumX += points[j].x;\n      sumZ += points[j].z;\n      count++;\n    }\n\n    smoothed.push({\n      distance: points[i].distance,\n      x: sumX / count,\n      z: sumZ / count,\n    });\n  }\n\n  return smoothed;\n}\n\n// Fill gaps in boundary data with linear interpolation\nfunction fillGaps(points: BoundaryPoint[], maxGapDistance: number = 100): BoundaryPoint[] {\n  if (points.length === 0) return points;\n\n  const filled: BoundaryPoint[] = [];\n\n  for (let i = 0; i < points.length; i++) {\n    filled.push(points[i]);\n\n    if (i < points.length - 1) {\n      const current = points[i];\n      const next = points[i + 1];\n      const gap = next.distance - current.distance;\n\n      if (gap > maxGapDistance) {\n        const numInterpolated = Math.floor(gap / 10);\n\n        for (let j = 1; j <= numInterpolated; j++) {\n          const t = j / (numInterpolated + 1);\n          filled.push({\n            distance: current.distance + gap * t,\n            x: current.x + (next.x - current.x) * t,\n            z: current.z + (next.z - current.z) * t,\n          });\n        }\n      }\n    }\n  }\n\n  // Handle wrap-around gap for closed tracks\n  if (filled.length > 1) {\n    const lastPoint = filled[filled.length - 1];\n    const firstPoint = filled[0];\n    const dx = firstPoint.x - lastPoint.x;\n    const dz = firstPoint.z - lastPoint.z;\n    const physicalDistance = Math.sqrt(dx * dx + dz * dz);\n\n    if (physicalDistance > 50) {\n      const numInterpolated = Math.floor(physicalDistance / 10);\n\n      for (let j = 1; j <= numInterpolated; j++) {\n        const t = j / (numInterpolated + 1);\n        filled.push({\n          distance: lastPoint.distance + j * 10,\n          x: lastPoint.x + dx * t,\n          z: lastPoint.z + dz * t,\n        });\n      }\n    }\n  }\n\n  return filled;\n}\n\n// Reduce point count by sampling every Nth point\nfunction downsample(points: BoundaryPoint[], factor: number = 5): BoundaryPoint[] {\n  return points.filter((_, i) => i % factor === 0);\n}\n\n// Cache processed boundaries to avoid recomputing\nconst boundaryCache = new Map<string, any>();\n\n// GET /api/boundaries/[track] - Returns processed track boundary data\nexport async function GET(\n  request: Request,\n  { params }: { params: Promise<{ track: string }> }\n) {\n  try {\n    const { track } = await params;\n\n    // Return cached result if available\n    if (boundaryCache.has(track)) {\n      return NextResponse.json(boundaryCache.get(track), {\n        headers: {\n          'Cache-Control': 'public, max-age=31536000, immutable',\n        },\n      });\n    }\n\n    const boundariesDir = path.join(process.cwd(), '..', 'boundaries');\n    const trackName = track;\n    const files = fs.readdirSync(boundariesDir);\n    const leftFile = files.find(f =>\n      f.includes(trackName.toLowerCase()) && f.includes('_left_boundary')\n    );\n    const rightFile = files.find(f =>\n      f.includes(trackName.toLowerCase()) && f.includes('_right_boundary')\n    );\n\n    if (!leftFile || !rightFile) {\n      return NextResponse.json(\n        { error: 'Boundary files not found' },\n        { status: 404 }\n      );\n    }\n\n    const leftBoundary: BoundaryFile = JSON.parse(\n      fs.readFileSync(path.join(boundariesDir, leftFile), 'utf-8')\n    );\n    const rightBoundary: BoundaryFile = JSON.parse(\n      fs.readFileSync(path.join(boundariesDir, rightFile), 'utf-8')\n    );\n\n    const leftFilled = fillGaps(leftBoundary.data, 100);\n    const rightFilled = fillGaps(rightBoundary.data, 100);\n    const leftSmoothed = smoothBoundary(leftFilled, 15);\n    const rightSmoothed = smoothBoundary(rightFilled, 15);\n    const leftDownsampled = downsample(leftSmoothed, 10);\n    const rightDownsampled = downsample(rightSmoothed, 10);\n\n    const result = {\n      track: {\n        id: leftBoundary.trackId,\n        name: leftBoundary.trackName,\n      },\n      left: leftDownsampled,\n      right: rightDownsampled,\n      originalPointCount: {\n        left: leftBoundary.pointCount,\n        right: rightBoundary.pointCount,\n      },\n      processedPointCount: {\n        left: leftDownsampled.length,\n        right: rightDownsampled.length,\n      },\n    };\n\n    // Cache the processed result\n    boundaryCache.set(track, result);\n\n    return NextResponse.json(result, {\n      headers: {\n        'Cache-Control': 'public, max-age=31536000, immutable',\n      },\n    });\n  } catch (error) {\n    console.error('Error loading boundaries:', error);\n    return NextResponse.json(\n      { error: 'Failed to load boundaries' },\n      { status: 500 }\n    );\n  }\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;;;;AAkBA,sDAAsD;AACtD,SAAS,eAAe,MAAuB,EAAE,aAAqB,EAAE;IACtE,IAAI,OAAO,MAAM,KAAK,GAAG,OAAO;IAEhC,MAAM,WAA4B,EAAE;IACpC,MAAM,aAAa,KAAK,KAAK,CAAC,aAAa;IAE3C,IAAK,IAAI,IAAI,GAAG,IAAI,OAAO,MAAM,EAAE,IAAK;QACtC,MAAM,QAAQ,KAAK,GAAG,CAAC,GAAG,IAAI;QAC9B,MAAM,MAAM,KAAK,GAAG,CAAC,OAAO,MAAM,EAAE,IAAI,aAAa;QAErD,IAAI,OAAO;QACX,IAAI,OAAO;QACX,IAAI,QAAQ;QAEZ,IAAK,IAAI,IAAI,OAAO,IAAI,KAAK,IAAK;YAChC,QAAQ,MAAM,CAAC,EAAE,CAAC,CAAC;YACnB,QAAQ,MAAM,CAAC,EAAE,CAAC,CAAC;YACnB;QACF;QAEA,SAAS,IAAI,CAAC;YACZ,UAAU,MAAM,CAAC,EAAE,CAAC,QAAQ;YAC5B,GAAG,OAAO;YACV,GAAG,OAAO;QACZ;IACF;IAEA,OAAO;AACT;AAEA,uDAAuD;AACvD,SAAS,SAAS,MAAuB,EAAE,iBAAyB,GAAG;IACrE,IAAI,OAAO,MAAM,KAAK,GAAG,OAAO;IAEhC,MAAM,SAA0B,EAAE;IAElC,IAAK,IAAI,IAAI,GAAG,IAAI,OAAO,MAAM,EAAE,IAAK;QACtC,OAAO,IAAI,CAAC,MAAM,CAAC,EAAE;QAErB,IAAI,IAAI,OAAO,MAAM,GAAG,GAAG;YACzB,MAAM,UAAU,MAAM,CAAC,EAAE;YACzB,MAAM,OAAO,MAAM,CAAC,IAAI,EAAE;YAC1B,MAAM,MAAM,KAAK,QAAQ,GAAG,QAAQ,QAAQ;YAE5C,IAAI,MAAM,gBAAgB;gBACxB,MAAM,kBAAkB,KAAK,KAAK,CAAC,MAAM;gBAEzC,IAAK,IAAI,IAAI,GAAG,KAAK,iBAAiB,IAAK;oBACzC,MAAM,IAAI,IAAI,CAAC,kBAAkB,CAAC;oBAClC,OAAO,IAAI,CAAC;wBACV,UAAU,QAAQ,QAAQ,GAAG,MAAM;wBACnC,GAAG,QAAQ,CAAC,GAAG,CAAC,KAAK,CAAC,GAAG,QAAQ,CAAC,IAAI;wBACtC,GAAG,QAAQ,CAAC,GAAG,CAAC,KAAK,CAAC,GAAG,QAAQ,CAAC,IAAI;oBACxC;gBACF;YACF;QACF;IACF;IAEA,2CAA2C;IAC3C,IAAI,OAAO,MAAM,GAAG,GAAG;QACrB,MAAM,YAAY,MAAM,CAAC,OAAO,MAAM,GAAG,EAAE;QAC3C,MAAM,aAAa,MAAM,CAAC,EAAE;QAC5B,MAAM,KAAK,WAAW,CAAC,GAAG,UAAU,CAAC;QACrC,MAAM,KAAK,WAAW,CAAC,GAAG,UAAU,CAAC;QACrC,MAAM,mBAAmB,KAAK,IAAI,CAAC,KAAK,KAAK,KAAK;QAElD,IAAI,mBAAmB,IAAI;YACzB,MAAM,kBAAkB,KAAK,KAAK,CAAC,mBAAmB;YAEtD,IAAK,IAAI,IAAI,GAAG,KAAK,iBAAiB,IAAK;gBACzC,MAAM,IAAI,IAAI,CAAC,kBAAkB,CAAC;gBAClC,OAAO,IAAI,CAAC;oBACV,UAAU,UAAU,QAAQ,GAAG,IAAI;oBACnC,GAAG,UAAU,CAAC,GAAG,KAAK;oBACtB,GAAG,UAAU,CAAC,GAAG,KAAK;gBACxB;YACF;QACF;IACF;IAEA,OAAO;AACT;AAEA,iDAAiD;AACjD,SAAS,WAAW,MAAuB,EAAE,SAAiB,CAAC;IAC7D,OAAO,OAAO,MAAM,CAAC,CAAC,GAAG,IAAM,IAAI,WAAW;AAChD;AAEA,kDAAkD;AAClD,MAAM,gBAAgB,IAAI;AAGnB,eAAe,IACpB,OAAgB,EAChB,EAAE,MAAM,EAA0C;IAElD,IAAI;QACF,MAAM,EAAE,KAAK,EAAE,GAAG,MAAM;QAExB,oCAAoC;QACpC,IAAI,cAAc,GAAG,CAAC,QAAQ;YAC5B,OAAO,iLAAY,CAAC,IAAI,CAAC,cAAc,GAAG,CAAC,QAAQ;gBACjD,SAAS;oBACP,iBAAiB;gBACnB;YACF;QACF;QAEA,MAAM,gBAAgB,4GAAI,CAAC,IAAI,CAAC,QAAQ,GAAG,IAAI,MAAM;QACrD,MAAM,YAAY;QAClB,MAAM,QAAQ,wGAAE,CAAC,WAAW,CAAC;QAC7B,MAAM,WAAW,MAAM,IAAI,CAAC,CAAA,IAC1B,EAAE,QAAQ,CAAC,UAAU,WAAW,OAAO,EAAE,QAAQ,CAAC;QAEpD,MAAM,YAAY,MAAM,IAAI,CAAC,CAAA,IAC3B,EAAE,QAAQ,CAAC,UAAU,WAAW,OAAO,EAAE,QAAQ,CAAC;QAGpD,IAAI,CAAC,YAAY,CAAC,WAAW;YAC3B,OAAO,iLAAY,CAAC,IAAI,CACtB;gBAAE,OAAO;YAA2B,GACpC;gBAAE,QAAQ;YAAI;QAElB;QAEA,MAAM,eAA6B,KAAK,KAAK,CAC3C,wGAAE,CAAC,YAAY,CAAC,4GAAI,CAAC,IAAI,CAAC,eAAe,WAAW;QAEtD,MAAM,gBAA8B,KAAK,KAAK,CAC5C,wGAAE,CAAC,YAAY,CAAC,4GAAI,CAAC,IAAI,CAAC,eAAe,YAAY;QAGvD,MAAM,aAAa,SAAS,aAAa,IAAI,EAAE;QAC/C,MAAM,cAAc,SAAS,cAAc,IAAI,EAAE;QACjD,MAAM,eAAe,eAAe,YAAY;QAChD,MAAM,gBAAgB,eAAe,aAAa;QAClD,MAAM,kBAAkB,WAAW,cAAc;QACjD,MAAM,mBAAmB,WAAW,eAAe;QAEnD,MAAM,SAAS;YACb,OAAO;gBACL,IAAI,aAAa,OAAO;gBACxB,MAAM,aAAa,SAAS;YAC9B;YACA,MAAM;YACN,OAAO;YACP,oBAAoB;gBAClB,MAAM,aAAa,UAAU;gBAC7B,OAAO,cAAc,UAAU;YACjC;YACA,qBAAqB;gBACnB,MAAM,gBAAgB,MAAM;gBAC5B,OAAO,iBAAiB,MAAM;YAChC;QACF;QAEA,6BAA6B;QAC7B,cAAc,GAAG,CAAC,OAAO;QAEzB,OAAO,iLAAY,CAAC,IAAI,CAAC,QAAQ;YAC/B,SAAS;gBACP,iBAAiB;YACnB;QACF;IACF,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,6BAA6B;QAC3C,OAAO,iLAAY,CAAC,IAAI,CACtB;YAAE,OAAO;QAA4B,GACrC;YAAE,QAAQ;QAAI;IAElB;AACF"}}]
}