{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 58, "column": 0}, "map": {"version":3,"sources":["file:///Users/haseebulhaqmalik/Desktop/lap-lens/src/analysis/lap-loader.ts"],"sourcesContent":["/**\n * Lap Loader - Loads saved lap data from CSV/JSON files\n *\n * Reads telemetry from ./laps directory and parses into NormalizedTelemetryPoint arrays.\n */\n\nimport * as fs from 'fs';\nimport * as path from 'path';\nimport { NormalizedTelemetryPoint } from '../types/f1-2024-packets';\n\nexport interface LapInfo {\n  filePath: string;\n  lapNumber: number;\n  timestamp: string;\n  pointCount: number;\n}\n\nexport class LapLoader {\n  private lapsDir: string;\n\n  constructor(lapsDir: string = './laps') {\n    this.lapsDir = lapsDir;\n  }\n\n  // List all available laps from JSON metadata\n  listAvailableLaps(): LapInfo[] {\n    if (!fs.existsSync(this.lapsDir)) {\n      return [];\n    }\n\n    const files = fs.readdirSync(this.lapsDir)\n      .filter(f => f.endsWith('.json'))\n      .map(f => {\n        const jsonPath = path.join(this.lapsDir, f);\n        const metadata = JSON.parse(fs.readFileSync(jsonPath, 'utf-8'));\n        return {\n          filePath: jsonPath.replace('.json', '.csv'),\n          lapNumber: metadata.lapNumber,\n          timestamp: metadata.timestamp,\n          pointCount: metadata.pointCount,\n        };\n      })\n      .sort((a, b) => a.lapNumber - b.lapNumber);\n\n    return files;\n  }\n\n  // Load telemetry from CSV file (parses all columns including yaw)\n  loadLap(csvPath: string): NormalizedTelemetryPoint[] {\n    const content = fs.readFileSync(csvPath, 'utf-8');\n    const lines = content.split('\\n').slice(1);\n\n    const points: NormalizedTelemetryPoint[] = [];\n\n    for (const line of lines) {\n      if (!line.trim()) continue;\n\n      const parts = line.split(',').map(p => parseFloat(p));\n      if (parts.length < 11) continue;\n\n      points.push({\n        time: parts[0],\n        distance: parts[1],\n        x: parts[2],\n        y: parts[3],\n        speed: parts[4],\n        throttle: parts[5],\n        brake: parts[6],\n        steering: parts[7],\n        gear: parts[8],\n        rpm: parts[9] || 0,      // RPM column (index 9)\n        gLat: parts[10] || 0,    // gLat column (index 10)\n        gLong: parts[11] || 0,   // gLong column (index 11)\n        yaw: parts[12] || 0,     // yaw column (index 12) - Backwards compatibility for old laps\n        lapNum: 0,\n      });\n    }\n\n    return points;\n  }\n\n  // Load lap by lap number (looks up CSV path from metadata)\n  loadLapByNumber(lapNumber: number): NormalizedTelemetryPoint[] | null {\n    const laps = this.listAvailableLaps();\n    const lap = laps.find(l => l.lapNumber === lapNumber);\n\n    if (!lap) {\n      return null;\n    }\n\n    return this.loadLap(lap.filePath);\n  }\n}\n"],"names":[],"mappings":"AAAA;;;;CAIC;;;;AAED;AACA;;;AAUO,MAAM;IACH,QAAgB;IAExB,YAAY,UAAkB,QAAQ,CAAE;QACtC,IAAI,CAAC,OAAO,GAAG;IACjB;IAEA,6CAA6C;IAC7C,oBAA+B;QAC7B,IAAI,CAAC,2GAAa,CAAC,IAAI,CAAC,OAAO,GAAG;YAChC,OAAO,EAAE;QACX;QAEA,MAAM,QAAQ,4GAAc,CAAC,IAAI,CAAC,OAAO,EACtC,MAAM,CAAC,CAAA,IAAK,EAAE,QAAQ,CAAC,UACvB,GAAG,CAAC,CAAA;YACH,MAAM,WAAW,yGAAS,CAAC,IAAI,CAAC,OAAO,EAAE;YACzC,MAAM,WAAW,KAAK,KAAK,CAAC,6GAAe,CAAC,UAAU;YACtD,OAAO;gBACL,UAAU,SAAS,OAAO,CAAC,SAAS;gBACpC,WAAW,SAAS,SAAS;gBAC7B,WAAW,SAAS,SAAS;gBAC7B,YAAY,SAAS,UAAU;YACjC;QACF,GACC,IAAI,CAAC,CAAC,GAAG,IAAM,EAAE,SAAS,GAAG,EAAE,SAAS;QAE3C,OAAO;IACT;IAEA,kEAAkE;IAClE,QAAQ,OAAe,EAA8B;QACnD,MAAM,UAAU,6GAAe,CAAC,SAAS;QACzC,MAAM,QAAQ,QAAQ,KAAK,CAAC,MAAM,KAAK,CAAC;QAExC,MAAM,SAAqC,EAAE;QAE7C,KAAK,MAAM,QAAQ,MAAO;YACxB,IAAI,CAAC,KAAK,IAAI,IAAI;YAElB,MAAM,QAAQ,KAAK,KAAK,CAAC,KAAK,GAAG,CAAC,CAAA,IAAK,WAAW;YAClD,IAAI,MAAM,MAAM,GAAG,IAAI;YAEvB,OAAO,IAAI,CAAC;gBACV,MAAM,KAAK,CAAC,EAAE;gBACd,UAAU,KAAK,CAAC,EAAE;gBAClB,GAAG,KAAK,CAAC,EAAE;gBACX,GAAG,KAAK,CAAC,EAAE;gBACX,OAAO,KAAK,CAAC,EAAE;gBACf,UAAU,KAAK,CAAC,EAAE;gBAClB,OAAO,KAAK,CAAC,EAAE;gBACf,UAAU,KAAK,CAAC,EAAE;gBAClB,MAAM,KAAK,CAAC,EAAE;gBACd,KAAK,KAAK,CAAC,EAAE,IAAI;gBACjB,MAAM,KAAK,CAAC,GAAG,IAAI;gBACnB,OAAO,KAAK,CAAC,GAAG,IAAI;gBACpB,KAAK,KAAK,CAAC,GAAG,IAAI;gBAClB,QAAQ;YACV;QACF;QAEA,OAAO;IACT;IAEA,2DAA2D;IAC3D,gBAAgB,SAAiB,EAAqC;QACpE,MAAM,OAAO,IAAI,CAAC,iBAAiB;QACnC,MAAM,MAAM,KAAK,IAAI,CAAC,CAAA,IAAK,EAAE,SAAS,KAAK;QAE3C,IAAI,CAAC,KAAK;YACR,OAAO;QACT;QAEA,OAAO,IAAI,CAAC,OAAO,CAAC,IAAI,QAAQ;IAClC;AACF"}},
    {"offset": {"line": 134, "column": 0}, "map": {"version":3,"sources":["file:///Users/haseebulhaqmalik/Desktop/lap-lens/src/analysis/interpolation.ts"],"sourcesContent":["/**\n * Interpolation - Linear interpolation utilities for telemetry data\n */\n\n/**\n * Linear interpolation between two values\n * Formula: a + (b - a) × t\n */\nexport function lerp(a: number, b: number, t: number): number {\n  return a + (b - a) * t;\n}\n\n/**\n * Interpolate Y value given X and two reference points\n * Formula: y = y0 + (y1 - y0) × ((x - x0) / (x1 - x0))\n */\nexport function interpolateValue(\n  x: number,\n  x0: number,\n  x1: number,\n  y0: number,\n  y1: number\n): number {\n  if (x1 === x0) return y0;\n  const t = (x - x0) / (x1 - x0);\n  return lerp(y0, y1, t);\n}\n\nexport interface InterpolatePoint {\n  [key: string]: number;\n}\n\n/**\n * Interpolate all numeric properties of a point\n * Used by LapNormalizer to create evenly-spaced samples\n */\nexport function interpolatePoint<T extends InterpolatePoint>(\n  distance: number,\n  point0: T,\n  point1: T,\n  distanceKey: string = 'distance'\n): T {\n  const d0 = point0[distanceKey];\n  const d1 = point1[distanceKey];\n\n  const result: any = {};\n\n  for (const key in point0) {\n    if (typeof point0[key] === 'number') {\n      result[key] = interpolateValue(distance, d0, d1, point0[key], point1[key]);\n    } else {\n      result[key] = point0[key];\n    }\n  }\n\n  return result as T;\n}\n"],"names":[],"mappings":"AAAA;;CAEC,GAED;;;CAGC;;;;;;;;AACM,SAAS,KAAK,CAAS,EAAE,CAAS,EAAE,CAAS;IAClD,OAAO,IAAI,CAAC,IAAI,CAAC,IAAI;AACvB;AAMO,SAAS,iBACd,CAAS,EACT,EAAU,EACV,EAAU,EACV,EAAU,EACV,EAAU;IAEV,IAAI,OAAO,IAAI,OAAO;IACtB,MAAM,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC,KAAK,EAAE;IAC7B,OAAO,KAAK,IAAI,IAAI;AACtB;AAUO,SAAS,iBACd,QAAgB,EAChB,MAAS,EACT,MAAS,EACT,cAAsB,UAAU;IAEhC,MAAM,KAAK,MAAM,CAAC,YAAY;IAC9B,MAAM,KAAK,MAAM,CAAC,YAAY;IAE9B,MAAM,SAAc,CAAC;IAErB,IAAK,MAAM,OAAO,OAAQ;QACxB,IAAI,OAAO,MAAM,CAAC,IAAI,KAAK,UAAU;YACnC,MAAM,CAAC,IAAI,GAAG,iBAAiB,UAAU,IAAI,IAAI,MAAM,CAAC,IAAI,EAAE,MAAM,CAAC,IAAI;QAC3E,OAAO;YACL,MAAM,CAAC,IAAI,GAAG,MAAM,CAAC,IAAI;QAC3B;IACF;IAEA,OAAO;AACT"}},
    {"offset": {"line": 172, "column": 0}, "map": {"version":3,"sources":["file:///Users/haseebulhaqmalik/Desktop/lap-lens/src/analysis/lap-normalizer.ts"],"sourcesContent":["/**\n * Lap Normalizer - Converts variable-spaced telemetry to even distance intervals\n *\n * Raw telemetry arrives at 60Hz (time-based) creating variable spacing.\n * Normalization creates consistent samples (default: 1 sample per meter) for accurate analysis.\n */\n\nimport { NormalizedTelemetryPoint } from '../types/f1-2024-packets';\nimport { interpolatePoint } from './interpolation';\n\nexport interface NormalizerOptions {\n  sampleRate: number;          // Distance between samples in meters\n}\n\nexport class LapNormalizer {\n  private options: NormalizerOptions;\n\n  constructor(options: Partial<NormalizerOptions> = {}) {\n    this.options = {\n      sampleRate: options.sampleRate || 1.0,\n    };\n  }\n\n  /**\n   * Normalize telemetry to consistent distance-based sampling\n   * Sorts points by distance, then interpolates at even intervals\n   */\n  normalize(points: NormalizedTelemetryPoint[], resetDistance: boolean = true): NormalizedTelemetryPoint[] {\n    if (points.length < 2) {\n      return points;\n    }\n\n    // Sort by distance (handles out-of-order UDP packets)\n    const sorted = [...points].sort((a, b) => a.distance - b.distance);\n\n    const minDistance = Math.floor(sorted[0].distance);\n    const maxDistance = Math.ceil(sorted[sorted.length - 1].distance);\n    const distanceOffset = resetDistance ? minDistance : 0;\n\n    const normalized: NormalizedTelemetryPoint[] = [];\n    let pointIndex = 0;\n\n    // Create evenly-spaced samples by interpolating\n    for (let d = minDistance; d <= maxDistance; d += this.options.sampleRate) {\n      // Find surrounding points\n      while (pointIndex < sorted.length - 1 && sorted[pointIndex + 1].distance < d) {\n        pointIndex++;\n      }\n\n      if (pointIndex >= sorted.length - 1) {\n        break;\n      }\n\n      const point0 = sorted[pointIndex];\n      const point1 = sorted[pointIndex + 1];\n\n      if (point1.distance < d) {\n        continue;\n      }\n\n      const interpolated = interpolatePoint(d, point0, point1, 'distance');\n      interpolated.distance = d - distanceOffset;\n\n      normalized.push(interpolated);\n    }\n\n    return normalized;\n  }\n\n  /**\n   * Get track length from telemetry\n   */\n  getTrackLength(points: NormalizedTelemetryPoint[]): number {\n    if (points.length === 0) return 0;\n    const sorted = [...points].sort((a, b) => a.distance - b.distance);\n    return sorted[sorted.length - 1].distance - sorted[0].distance;\n  }\n}\n"],"names":[],"mappings":"AAAA;;;;;CAKC;;;;AAGD;;AAMO,MAAM;IACH,QAA2B;IAEnC,YAAY,UAAsC,CAAC,CAAC,CAAE;QACpD,IAAI,CAAC,OAAO,GAAG;YACb,YAAY,QAAQ,UAAU,IAAI;QACpC;IACF;IAEA;;;GAGC,GACD,UAAU,MAAkC,EAAE,gBAAyB,IAAI,EAA8B;QACvG,IAAI,OAAO,MAAM,GAAG,GAAG;YACrB,OAAO;QACT;QAEA,sDAAsD;QACtD,MAAM,SAAS;eAAI;SAAO,CAAC,IAAI,CAAC,CAAC,GAAG,IAAM,EAAE,QAAQ,GAAG,EAAE,QAAQ;QAEjE,MAAM,cAAc,KAAK,KAAK,CAAC,MAAM,CAAC,EAAE,CAAC,QAAQ;QACjD,MAAM,cAAc,KAAK,IAAI,CAAC,MAAM,CAAC,OAAO,MAAM,GAAG,EAAE,CAAC,QAAQ;QAChE,MAAM,iBAAiB,gBAAgB,cAAc;QAErD,MAAM,aAAyC,EAAE;QACjD,IAAI,aAAa;QAEjB,gDAAgD;QAChD,IAAK,IAAI,IAAI,aAAa,KAAK,aAAa,KAAK,IAAI,CAAC,OAAO,CAAC,UAAU,CAAE;YACxE,0BAA0B;YAC1B,MAAO,aAAa,OAAO,MAAM,GAAG,KAAK,MAAM,CAAC,aAAa,EAAE,CAAC,QAAQ,GAAG,EAAG;gBAC5E;YACF;YAEA,IAAI,cAAc,OAAO,MAAM,GAAG,GAAG;gBACnC;YACF;YAEA,MAAM,SAAS,MAAM,CAAC,WAAW;YACjC,MAAM,SAAS,MAAM,CAAC,aAAa,EAAE;YAErC,IAAI,OAAO,QAAQ,GAAG,GAAG;gBACvB;YACF;YAEA,MAAM,eAAe,IAAA,gLAAgB,EAAC,GAAG,QAAQ,QAAQ;YACzD,aAAa,QAAQ,GAAG,IAAI;YAE5B,WAAW,IAAI,CAAC;QAClB;QAEA,OAAO;IACT;IAEA;;GAEC,GACD,eAAe,MAAkC,EAAU;QACzD,IAAI,OAAO,MAAM,KAAK,GAAG,OAAO;QAChC,MAAM,SAAS;eAAI;SAAO,CAAC,IAAI,CAAC,CAAC,GAAG,IAAM,EAAE,QAAQ,GAAG,EAAE,QAAQ;QACjE,OAAO,MAAM,CAAC,OAAO,MAAM,GAAG,EAAE,CAAC,QAAQ,GAAG,MAAM,CAAC,EAAE,CAAC,QAAQ;IAChE;AACF"}},
    {"offset": {"line": 240, "column": 0}, "map": {"version":3,"sources":["file:///Users/haseebulhaqmalik/Desktop/lap-lens/src/analysis/lap-aligner.ts"],"sourcesContent":["/**\n * Lap Aligner - Aligns two laps by distance for comparison\n *\n * Finds overlapping distance range between laps and trims to matching segments.\n */\n\nimport { NormalizedTelemetryPoint } from '../types/f1-2024-packets';\n\nexport interface AlignedLaps {\n  lapA: NormalizedTelemetryPoint[];\n  lapB: NormalizedTelemetryPoint[];\n  startDistance: number;\n  endDistance: number;\n  length: number;\n}\n\nexport class LapAligner {\n  // Align laps by finding overlapping distance range\n  alignLaps(\n    lapA: NormalizedTelemetryPoint[],\n    lapB: NormalizedTelemetryPoint[]\n  ): AlignedLaps {\n    if (lapA.length === 0 || lapB.length === 0) {\n      throw new Error('Cannot align empty laps');\n    }\n\n    const startA = lapA[0].distance;\n    const endA = lapA[lapA.length - 1].distance;\n\n    const startB = lapB[0].distance;\n    const endB = lapB[lapB.length - 1].distance;\n\n    const startDistance = Math.max(startA, startB);\n    const endDistance = Math.min(endA, endB);\n\n    if (endDistance <= startDistance) {\n      throw new Error('Laps do not overlap');\n    }\n\n    const alignedA = lapA.filter(\n      p => p.distance >= startDistance && p.distance <= endDistance\n    );\n    const alignedB = lapB.filter(\n      p => p.distance >= startDistance && p.distance <= endDistance\n    );\n\n    return {\n      lapA: alignedA,\n      lapB: alignedB,\n      startDistance,\n      endDistance,\n      length: endDistance - startDistance,\n    };\n  }\n\n  // Trim laps to same point count (alternative to distance-based alignment)\n  trimToSameLength(\n    lapA: NormalizedTelemetryPoint[],\n    lapB: NormalizedTelemetryPoint[]\n  ): AlignedLaps {\n    const minLength = Math.min(lapA.length, lapB.length);\n\n    return {\n      lapA: lapA.slice(0, minLength),\n      lapB: lapB.slice(0, minLength),\n      startDistance: lapA[0].distance,\n      endDistance: lapA[minLength - 1].distance,\n      length: lapA[minLength - 1].distance - lapA[0].distance,\n    };\n  }\n}\n"],"names":[],"mappings":"AAAA;;;;CAIC;;;;AAYM,MAAM;IACX,mDAAmD;IACnD,UACE,IAAgC,EAChC,IAAgC,EACnB;QACb,IAAI,KAAK,MAAM,KAAK,KAAK,KAAK,MAAM,KAAK,GAAG;YAC1C,MAAM,IAAI,MAAM;QAClB;QAEA,MAAM,SAAS,IAAI,CAAC,EAAE,CAAC,QAAQ;QAC/B,MAAM,OAAO,IAAI,CAAC,KAAK,MAAM,GAAG,EAAE,CAAC,QAAQ;QAE3C,MAAM,SAAS,IAAI,CAAC,EAAE,CAAC,QAAQ;QAC/B,MAAM,OAAO,IAAI,CAAC,KAAK,MAAM,GAAG,EAAE,CAAC,QAAQ;QAE3C,MAAM,gBAAgB,KAAK,GAAG,CAAC,QAAQ;QACvC,MAAM,cAAc,KAAK,GAAG,CAAC,MAAM;QAEnC,IAAI,eAAe,eAAe;YAChC,MAAM,IAAI,MAAM;QAClB;QAEA,MAAM,WAAW,KAAK,MAAM,CAC1B,CAAA,IAAK,EAAE,QAAQ,IAAI,iBAAiB,EAAE,QAAQ,IAAI;QAEpD,MAAM,WAAW,KAAK,MAAM,CAC1B,CAAA,IAAK,EAAE,QAAQ,IAAI,iBAAiB,EAAE,QAAQ,IAAI;QAGpD,OAAO;YACL,MAAM;YACN,MAAM;YACN;YACA;YACA,QAAQ,cAAc;QACxB;IACF;IAEA,0EAA0E;IAC1E,iBACE,IAAgC,EAChC,IAAgC,EACnB;QACb,MAAM,YAAY,KAAK,GAAG,CAAC,KAAK,MAAM,EAAE,KAAK,MAAM;QAEnD,OAAO;YACL,MAAM,KAAK,KAAK,CAAC,GAAG;YACpB,MAAM,KAAK,KAAK,CAAC,GAAG;YACpB,eAAe,IAAI,CAAC,EAAE,CAAC,QAAQ;YAC/B,aAAa,IAAI,CAAC,YAAY,EAAE,CAAC,QAAQ;YACzC,QAAQ,IAAI,CAAC,YAAY,EAAE,CAAC,QAAQ,GAAG,IAAI,CAAC,EAAE,CAAC,QAAQ;QACzD;IACF;AACF"}},
    {"offset": {"line": 289, "column": 0}, "map": {"version":3,"sources":["file:///Users/haseebulhaqmalik/Desktop/lap-lens/src/analysis/corner-database.ts"],"sourcesContent":["import * as fs from 'fs';\nimport * as path from 'path';\nimport { Corner, CornerDirection, CornerType } from './corner-types';\nimport { BrakingZone, BrakingIntensity } from './braking-zone-detector';\n\nexport interface BrakingZoneEntry {\n  entryDistance: number;\n  peakDistance: number;\n  exitDistance: number;\n  entrySpeed: number;\n  minSpeed: number;\n  exitSpeed: number;\n  speedLoss: number;\n  peakBrakePressure: number;\n  avgBrakePressure: number;\n  peakDeceleration: number;\n  avgDeceleration: number;\n  brakingDistance: number;\n  brakingDuration: number;\n  intensity: BrakingIntensity;\n  isTrailBraking: boolean;\n}\n\nexport interface CornerDatabaseEntry {\n  number: number;\n  name?: string;\n  entryDistance: number;\n  apexDistance: number;\n  exitDistance: number;\n  // Store actual track coordinates for accurate visualization\n  apexX: number;\n  apexY: number;\n  type: CornerType;\n  direction: CornerDirection;\n  brakingZone?: BrakingZoneEntry;\n}\n\nexport interface TrackCornerDatabase {\n  trackId: number;\n  trackName: string;\n  trackLength: number;\n  totalCorners: number;\n  corners: CornerDatabaseEntry[];\n  createdAt: string;\n  updatedAt: string;\n}\n\nexport class CornerDatabase {\n  private databaseDir: string;\n\n  constructor(databaseDir: string = './corners') {\n    this.databaseDir = databaseDir;\n    if (!fs.existsSync(databaseDir)) {\n      fs.mkdirSync(databaseDir, { recursive: true });\n    }\n  }\n\n  private sanitizeTrackName(trackName: string): string {\n    const match = trackName.match(/\\(([^)]+)\\)/);\n    const baseName = match ? match[1] : trackName;\n\n    return baseName\n      .toLowerCase()\n      .trim()\n      .replace(/\\s+/g, '-')\n      .replace(/[^a-z0-9-]/g, '');\n  }\n\n  private getFilePath(trackName: string): string {\n    const sanitized = this.sanitizeTrackName(trackName);\n    return path.join(this.databaseDir, `${sanitized}.json`);\n  }\n\n  private getLegacyFilePath(trackId: number): string {\n    return path.join(this.databaseDir, `track_${trackId}.json`);\n  }\n\n  hasTrackData(trackName: string, trackId?: number): boolean {\n    const filePath = this.getFilePath(trackName);\n    if (fs.existsSync(filePath)) return true;\n\n    if (trackId !== undefined) {\n      const legacyPath = this.getLegacyFilePath(trackId);\n      return fs.existsSync(legacyPath);\n    }\n\n    return false;\n  }\n\n  loadTrackCorners(trackName: string, trackId?: number): TrackCornerDatabase | null {\n    let filePath = this.getFilePath(trackName);\n\n    if (!fs.existsSync(filePath) && trackId !== undefined) {\n      const legacyPath = this.getLegacyFilePath(trackId);\n      if (fs.existsSync(legacyPath)) {\n        filePath = legacyPath;\n      }\n    }\n\n    if (!fs.existsSync(filePath)) {\n      return null;\n    }\n\n    try {\n      const data = fs.readFileSync(filePath, 'utf-8');\n      return JSON.parse(data) as TrackCornerDatabase;\n    } catch (error) {\n      console.error(`Failed to load corner database for track ${trackName}:`, error);\n      return null;\n    }\n  }\n\n  saveTrackCorners(\n    trackName: string,\n    trackId: number,\n    trackLength: number,\n    corners: Corner[],\n    brakingZones?: BrakingZone[],\n    telemetry?: Array<{ distance: number; x: number; y: number }>\n  ): void {\n    const filePath = this.getFilePath(trackName);\n    const isUpdate = fs.existsSync(filePath);\n\n    let createdAt = new Date().toISOString();\n    if (isUpdate) {\n      const existing = this.loadTrackCorners(trackName, trackId);\n      if (existing) {\n        createdAt = existing.createdAt;\n      }\n    }\n\n    const brakingZoneMap = new Map<number, BrakingZone>();\n    if (brakingZones) {\n      for (const corner of corners) {\n        const cornerNumber = corners.indexOf(corner) + 1;\n        const candidateZones = brakingZones.filter((zone) => {\n          const distanceToCorner = corner.entryDistance - zone.exitDistance;\n          return distanceToCorner >= -100 && distanceToCorner <= 50;\n        });\n\n        if (candidateZones.length > 0) {\n          const primaryZone = candidateZones.reduce((best, current) => {\n            const bestDistance = Math.abs(corner.entryDistance - best.exitDistance);\n            const currentDistance = Math.abs(corner.entryDistance - current.exitDistance);\n            return currentDistance < bestDistance ? current : best;\n          });\n          brakingZoneMap.set(cornerNumber, primaryZone);\n        }\n      }\n    }\n\n    const databaseEntries: CornerDatabaseEntry[] = corners.map((corner, index) => {\n      const cornerNumber = index + 1;\n\n      // Find apex coordinates from telemetry\n      let apexX = 0, apexY = 0;\n      if (telemetry) {\n        // Find closest telemetry point to apex distance\n        let closestPoint = telemetry[0];\n        let minDist = Infinity;\n        for (const point of telemetry) {\n          const dist = Math.abs(point.distance - corner.apexDistance);\n          if (dist < minDist) {\n            minDist = dist;\n            closestPoint = point;\n          }\n        }\n        apexX = closestPoint.x;\n        apexY = closestPoint.y;\n      }\n\n      const entry: CornerDatabaseEntry = {\n        number: cornerNumber,\n        entryDistance: Math.round(corner.entryDistance),\n        apexDistance: Math.round(corner.apexDistance),\n        exitDistance: Math.round(corner.exitDistance),\n        apexX: Math.round(apexX * 100) / 100, // Store with 2 decimal places\n        apexY: Math.round(apexY * 100) / 100,\n        type: corner.type,\n        direction: corner.direction,\n      };\n\n      const brakingZone = brakingZoneMap.get(cornerNumber);\n      if (brakingZone) {\n        entry.brakingZone = {\n          entryDistance: Math.round(brakingZone.entryDistance),\n          peakDistance: Math.round(brakingZone.peakDistance),\n          exitDistance: Math.round(brakingZone.exitDistance),\n          entrySpeed: Math.round(brakingZone.entrySpeed),\n          minSpeed: Math.round(brakingZone.minSpeed),\n          exitSpeed: Math.round(brakingZone.exitSpeed),\n          speedLoss: Math.round(brakingZone.speedLoss),\n          peakBrakePressure: Math.round(brakingZone.peakBrakePressure * 100) / 100,\n          avgBrakePressure: Math.round(brakingZone.avgBrakePressure * 100) / 100,\n          peakDeceleration: Math.round(brakingZone.peakDeceleration * 100) / 100,\n          avgDeceleration: Math.round(brakingZone.avgDeceleration * 100) / 100,\n          brakingDistance: Math.round(brakingZone.brakingDistance),\n          brakingDuration: Math.round(brakingZone.brakingDuration * 100) / 100,\n          intensity: brakingZone.intensity,\n          isTrailBraking: brakingZone.isTrailBraking,\n        };\n      }\n\n      return entry;\n    });\n\n    const database: TrackCornerDatabase = {\n      trackId,\n      trackName,\n      trackLength: Math.round(trackLength),\n      totalCorners: corners.length,\n      corners: databaseEntries,\n      createdAt,\n      updatedAt: new Date().toISOString(),\n    };\n\n    fs.writeFileSync(filePath, JSON.stringify(database, null, 2));\n  }\n\n  findCornerAtDistance(trackName: string, distance: number, trackId?: number, tolerance: number = 10): CornerDatabaseEntry | null {\n    const trackData = this.loadTrackCorners(trackName, trackId);\n\n    if (!trackData) {\n      return null;\n    }\n\n    for (const corner of trackData.corners) {\n      if (distance >= corner.entryDistance - tolerance && distance <= corner.exitDistance + tolerance) {\n        return corner;\n      }\n    }\n\n    return null;\n  }\n\n  getCornerPhase(trackName: string, distance: number, trackId?: number, tolerance: number = 10): 'entry' | 'apex' | 'exit' | null {\n    const corner = this.findCornerAtDistance(trackName, distance, trackId, tolerance);\n\n    if (!corner) {\n      return null;\n    }\n\n    const distToEntry = Math.abs(distance - corner.entryDistance);\n    const distToApex = Math.abs(distance - corner.apexDistance);\n    const distToExit = Math.abs(distance - corner.exitDistance);\n\n    if (distToEntry <= distToApex && distToEntry <= distToExit) {\n      return 'entry';\n    } else if (distToApex <= distToEntry && distToApex <= distToExit) {\n      return 'apex';\n    } else {\n      return 'exit';\n    }\n  }\n\n  listAvailableTracks(): string[] {\n    if (!fs.existsSync(this.databaseDir)) {\n      return [];\n    }\n\n    const files = fs.readdirSync(this.databaseDir)\n      .filter(f => f.endsWith('.json'))\n      .map(f => f.replace('.json', ''));\n\n    return files.sort();\n  }\n\n  deleteTrackCorners(trackName: string, trackId?: number): boolean {\n    const filePath = this.getFilePath(trackName);\n\n    if (fs.existsSync(filePath)) {\n      fs.unlinkSync(filePath);\n      return true;\n    }\n\n    if (trackId !== undefined) {\n      const legacyPath = this.getLegacyFilePath(trackId);\n      if (fs.existsSync(legacyPath)) {\n        fs.unlinkSync(legacyPath);\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  getAllTrackData(): TrackCornerDatabase[] {\n    const trackNames = this.listAvailableTracks();\n    const allData: TrackCornerDatabase[] = [];\n\n    for (const trackName of trackNames) {\n      const data = this.loadTrackCorners(trackName);\n      if (data) {\n        allData.push(data);\n      }\n    }\n\n    return allData;\n  }\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AA8CO,MAAM;IACH,YAAoB;IAE5B,YAAY,cAAsB,WAAW,CAAE;QAC7C,IAAI,CAAC,WAAW,GAAG;QACnB,IAAI,CAAC,2GAAa,CAAC,cAAc;YAC/B,0GAAY,CAAC,aAAa;gBAAE,WAAW;YAAK;QAC9C;IACF;IAEQ,kBAAkB,SAAiB,EAAU;QACnD,MAAM,QAAQ,UAAU,KAAK,CAAC;QAC9B,MAAM,WAAW,QAAQ,KAAK,CAAC,EAAE,GAAG;QAEpC,OAAO,SACJ,WAAW,GACX,IAAI,GACJ,OAAO,CAAC,QAAQ,KAChB,OAAO,CAAC,eAAe;IAC5B;IAEQ,YAAY,SAAiB,EAAU;QAC7C,MAAM,YAAY,IAAI,CAAC,iBAAiB,CAAC;QACzC,OAAO,yGAAS,CAAC,IAAI,CAAC,WAAW,EAAE,GAAG,UAAU,KAAK,CAAC;IACxD;IAEQ,kBAAkB,OAAe,EAAU;QACjD,OAAO,yGAAS,CAAC,IAAI,CAAC,WAAW,EAAE,CAAC,MAAM,EAAE,QAAQ,KAAK,CAAC;IAC5D;IAEA,aAAa,SAAiB,EAAE,OAAgB,EAAW;QACzD,MAAM,WAAW,IAAI,CAAC,WAAW,CAAC;QAClC,IAAI,2GAAa,CAAC,WAAW,OAAO;QAEpC,IAAI,YAAY,WAAW;YACzB,MAAM,aAAa,IAAI,CAAC,iBAAiB,CAAC;YAC1C,OAAO,2GAAa,CAAC;QACvB;QAEA,OAAO;IACT;IAEA,iBAAiB,SAAiB,EAAE,OAAgB,EAA8B;QAChF,IAAI,WAAW,IAAI,CAAC,WAAW,CAAC;QAEhC,IAAI,CAAC,2GAAa,CAAC,aAAa,YAAY,WAAW;YACrD,MAAM,aAAa,IAAI,CAAC,iBAAiB,CAAC;YAC1C,IAAI,2GAAa,CAAC,aAAa;gBAC7B,WAAW;YACb;QACF;QAEA,IAAI,CAAC,2GAAa,CAAC,WAAW;YAC5B,OAAO;QACT;QAEA,IAAI;YACF,MAAM,OAAO,6GAAe,CAAC,UAAU;YACvC,OAAO,KAAK,KAAK,CAAC;QACpB,EAAE,OAAO,OAAO;YACd,QAAQ,KAAK,CAAC,CAAC,yCAAyC,EAAE,UAAU,CAAC,CAAC,EAAE;YACxE,OAAO;QACT;IACF;IAEA,iBACE,SAAiB,EACjB,OAAe,EACf,WAAmB,EACnB,OAAiB,EACjB,YAA4B,EAC5B,SAA6D,EACvD;QACN,MAAM,WAAW,IAAI,CAAC,WAAW,CAAC;QAClC,MAAM,WAAW,2GAAa,CAAC;QAE/B,IAAI,YAAY,IAAI,OAAO,WAAW;QACtC,IAAI,UAAU;YACZ,MAAM,WAAW,IAAI,CAAC,gBAAgB,CAAC,WAAW;YAClD,IAAI,UAAU;gBACZ,YAAY,SAAS,SAAS;YAChC;QACF;QAEA,MAAM,iBAAiB,IAAI;QAC3B,IAAI,cAAc;YAChB,KAAK,MAAM,UAAU,QAAS;gBAC5B,MAAM,eAAe,QAAQ,OAAO,CAAC,UAAU;gBAC/C,MAAM,iBAAiB,aAAa,MAAM,CAAC,CAAC;oBAC1C,MAAM,mBAAmB,OAAO,aAAa,GAAG,KAAK,YAAY;oBACjE,OAAO,oBAAoB,CAAC,OAAO,oBAAoB;gBACzD;gBAEA,IAAI,eAAe,MAAM,GAAG,GAAG;oBAC7B,MAAM,cAAc,eAAe,MAAM,CAAC,CAAC,MAAM;wBAC/C,MAAM,eAAe,KAAK,GAAG,CAAC,OAAO,aAAa,GAAG,KAAK,YAAY;wBACtE,MAAM,kBAAkB,KAAK,GAAG,CAAC,OAAO,aAAa,GAAG,QAAQ,YAAY;wBAC5E,OAAO,kBAAkB,eAAe,UAAU;oBACpD;oBACA,eAAe,GAAG,CAAC,cAAc;gBACnC;YACF;QACF;QAEA,MAAM,kBAAyC,QAAQ,GAAG,CAAC,CAAC,QAAQ;YAClE,MAAM,eAAe,QAAQ;YAE7B,uCAAuC;YACvC,IAAI,QAAQ,GAAG,QAAQ;YACvB,IAAI,WAAW;gBACb,gDAAgD;gBAChD,IAAI,eAAe,SAAS,CAAC,EAAE;gBAC/B,IAAI,UAAU;gBACd,KAAK,MAAM,SAAS,UAAW;oBAC7B,MAAM,OAAO,KAAK,GAAG,CAAC,MAAM,QAAQ,GAAG,OAAO,YAAY;oBAC1D,IAAI,OAAO,SAAS;wBAClB,UAAU;wBACV,eAAe;oBACjB;gBACF;gBACA,QAAQ,aAAa,CAAC;gBACtB,QAAQ,aAAa,CAAC;YACxB;YAEA,MAAM,QAA6B;gBACjC,QAAQ;gBACR,eAAe,KAAK,KAAK,CAAC,OAAO,aAAa;gBAC9C,cAAc,KAAK,KAAK,CAAC,OAAO,YAAY;gBAC5C,cAAc,KAAK,KAAK,CAAC,OAAO,YAAY;gBAC5C,OAAO,KAAK,KAAK,CAAC,QAAQ,OAAO;gBACjC,OAAO,KAAK,KAAK,CAAC,QAAQ,OAAO;gBACjC,MAAM,OAAO,IAAI;gBACjB,WAAW,OAAO,SAAS;YAC7B;YAEA,MAAM,cAAc,eAAe,GAAG,CAAC;YACvC,IAAI,aAAa;gBACf,MAAM,WAAW,GAAG;oBAClB,eAAe,KAAK,KAAK,CAAC,YAAY,aAAa;oBACnD,cAAc,KAAK,KAAK,CAAC,YAAY,YAAY;oBACjD,cAAc,KAAK,KAAK,CAAC,YAAY,YAAY;oBACjD,YAAY,KAAK,KAAK,CAAC,YAAY,UAAU;oBAC7C,UAAU,KAAK,KAAK,CAAC,YAAY,QAAQ;oBACzC,WAAW,KAAK,KAAK,CAAC,YAAY,SAAS;oBAC3C,WAAW,KAAK,KAAK,CAAC,YAAY,SAAS;oBAC3C,mBAAmB,KAAK,KAAK,CAAC,YAAY,iBAAiB,GAAG,OAAO;oBACrE,kBAAkB,KAAK,KAAK,CAAC,YAAY,gBAAgB,GAAG,OAAO;oBACnE,kBAAkB,KAAK,KAAK,CAAC,YAAY,gBAAgB,GAAG,OAAO;oBACnE,iBAAiB,KAAK,KAAK,CAAC,YAAY,eAAe,GAAG,OAAO;oBACjE,iBAAiB,KAAK,KAAK,CAAC,YAAY,eAAe;oBACvD,iBAAiB,KAAK,KAAK,CAAC,YAAY,eAAe,GAAG,OAAO;oBACjE,WAAW,YAAY,SAAS;oBAChC,gBAAgB,YAAY,cAAc;gBAC5C;YACF;YAEA,OAAO;QACT;QAEA,MAAM,WAAgC;YACpC;YACA;YACA,aAAa,KAAK,KAAK,CAAC;YACxB,cAAc,QAAQ,MAAM;YAC5B,SAAS;YACT;YACA,WAAW,IAAI,OAAO,WAAW;QACnC;QAEA,8GAAgB,CAAC,UAAU,KAAK,SAAS,CAAC,UAAU,MAAM;IAC5D;IAEA,qBAAqB,SAAiB,EAAE,QAAgB,EAAE,OAAgB,EAAE,YAAoB,EAAE,EAA8B;QAC9H,MAAM,YAAY,IAAI,CAAC,gBAAgB,CAAC,WAAW;QAEnD,IAAI,CAAC,WAAW;YACd,OAAO;QACT;QAEA,KAAK,MAAM,UAAU,UAAU,OAAO,CAAE;YACtC,IAAI,YAAY,OAAO,aAAa,GAAG,aAAa,YAAY,OAAO,YAAY,GAAG,WAAW;gBAC/F,OAAO;YACT;QACF;QAEA,OAAO;IACT;IAEA,eAAe,SAAiB,EAAE,QAAgB,EAAE,OAAgB,EAAE,YAAoB,EAAE,EAAoC;QAC9H,MAAM,SAAS,IAAI,CAAC,oBAAoB,CAAC,WAAW,UAAU,SAAS;QAEvE,IAAI,CAAC,QAAQ;YACX,OAAO;QACT;QAEA,MAAM,cAAc,KAAK,GAAG,CAAC,WAAW,OAAO,aAAa;QAC5D,MAAM,aAAa,KAAK,GAAG,CAAC,WAAW,OAAO,YAAY;QAC1D,MAAM,aAAa,KAAK,GAAG,CAAC,WAAW,OAAO,YAAY;QAE1D,IAAI,eAAe,cAAc,eAAe,YAAY;YAC1D,OAAO;QACT,OAAO,IAAI,cAAc,eAAe,cAAc,YAAY;YAChE,OAAO;QACT,OAAO;YACL,OAAO;QACT;IACF;IAEA,sBAAgC;QAC9B,IAAI,CAAC,2GAAa,CAAC,IAAI,CAAC,WAAW,GAAG;YACpC,OAAO,EAAE;QACX;QAEA,MAAM,QAAQ,4GAAc,CAAC,IAAI,CAAC,WAAW,EAC1C,MAAM,CAAC,CAAA,IAAK,EAAE,QAAQ,CAAC,UACvB,GAAG,CAAC,CAAA,IAAK,EAAE,OAAO,CAAC,SAAS;QAE/B,OAAO,MAAM,IAAI;IACnB;IAEA,mBAAmB,SAAiB,EAAE,OAAgB,EAAW;QAC/D,MAAM,WAAW,IAAI,CAAC,WAAW,CAAC;QAElC,IAAI,2GAAa,CAAC,WAAW;YAC3B,2GAAa,CAAC;YACd,OAAO;QACT;QAEA,IAAI,YAAY,WAAW;YACzB,MAAM,aAAa,IAAI,CAAC,iBAAiB,CAAC;YAC1C,IAAI,2GAAa,CAAC,aAAa;gBAC7B,2GAAa,CAAC;gBACd,OAAO;YACT;QACF;QAEA,OAAO;IACT;IAEA,kBAAyC;QACvC,MAAM,aAAa,IAAI,CAAC,mBAAmB;QAC3C,MAAM,UAAiC,EAAE;QAEzC,KAAK,MAAM,aAAa,WAAY;YAClC,MAAM,OAAO,IAAI,CAAC,gBAAgB,CAAC;YACnC,IAAI,MAAM;gBACR,QAAQ,IAAI,CAAC;YACf;QACF;QAEA,OAAO;IACT;AACF"}},
    {"offset": {"line": 502, "column": 0}, "map": {"version":3,"sources":["file:///Users/haseebulhaqmalik/Desktop/lap-lens/src/analysis/sector-analysis.ts"],"sourcesContent":["/**\n * Sector Analysis - Track sector performance comparison\n *\n * Divides track into sectors (configured or auto-detected thirds)\n * Compares sector times, speeds, and driving inputs between laps\n */\n\nimport { NormalizedTelemetryPoint } from '../types/f1-2024-packets';\nimport { AlignedLaps } from './lap-aligner';\nimport { CornerDatabase } from './corner-database';\n\nexport interface SectorBoundary {\n  sectorNumber: number;        // Sector ID (1, 2, 3)\n  startDistance: number;        // Start distance in meters\n  endDistance: number;          // End distance in meters\n}\n\nexport interface SectorTime {\n  sectorNumber: number;\n  startDistance: number;\n  endDistance: number;\n  distance: number;             // Sector length\n  time: number;                 // Time through sector\n  avgSpeed: number;             // Average speed (km/h)\n  minSpeed: number;             // Minimum speed in sector\n  maxSpeed: number;             // Maximum speed in sector\n  avgThrottle: number;          // Average throttle %\n  avgBrake: number;             // Average brake %\n  cornerCount: number;          // Number of corners in sector\n}\n\nexport interface SectorComparison {\n  sectorNumber: number;\n  startDistance: number;\n  endDistance: number;\n  distance: number;\n\n  lapA: SectorTime;             // Sector data for lap A\n  lapB: SectorTime;             // Sector data for lap B\n\n  timeDelta: number;            // Time difference (lapA - lapB)\n  avgSpeedDelta: number;        // Speed difference\n\n  timeGainPercentage: number;   // % time gained/lost\n}\n\nexport interface SectorAnalysis {\n  sectors: SectorComparison[];\n  summary: {\n    totalTimeDelta: number;\n    fastestSector: { sectorNumber: number; timeDelta: number };\n    slowestSector: { sectorNumber: number; timeDelta: number };\n  };\n}\n\nexport interface SectorConfig {\n  trackName: string;\n  sectors: SectorBoundary[];    // Custom sector boundaries\n}\n\nexport class SectorAnalyzer {\n  private cornerDb: CornerDatabase;\n  private sectorConfigs: Map<string, SectorBoundary[]>;\n\n  constructor(cornerDbPath?: string) {\n    this.cornerDb = new CornerDatabase(cornerDbPath);\n    this.sectorConfigs = new Map();\n    this.initializeDefaultConfigs();\n  }\n\n  /**\n   * Initialize track-specific sector configurations\n   * Add configs for tracks with known sector boundaries\n   */\n  private initializeDefaultConfigs(): void {\n    this.sectorConfigs.set('bahrain', [\n      { sectorNumber: 1, startDistance: 0, endDistance: 1900 },\n      { sectorNumber: 2, startDistance: 1900, endDistance: 3700 },\n      { sectorNumber: 3, startDistance: 3700, endDistance: 999999 },\n    ]);\n  }\n\n  /**\n   * Analyze sectors between two laps\n   * Uses configured boundaries or auto-detects thirds\n   */\n  analyzeSectors(\n    aligned: AlignedLaps,\n    trackName: string,\n    trackId?: number\n  ): SectorAnalysis {\n    const boundaries = this.getSectorBoundaries(trackName, aligned.lapA);\n    const sectors: SectorComparison[] = [];\n\n    // Calculate metrics for each sector\n    for (const boundary of boundaries) {\n      const sectorA = this.calculateSectorTime(aligned.lapA, boundary, trackName, trackId);\n      const sectorB = this.calculateSectorTime(aligned.lapB, boundary, trackName, trackId);\n\n      const timeDelta = sectorA.time - sectorB.time;\n      const avgSpeedDelta = sectorA.avgSpeed - sectorB.avgSpeed;\n      const timeGainPercentage = sectorB.time > 0 ? (timeDelta / sectorB.time) * 100 : 0;\n\n      sectors.push({\n        sectorNumber: boundary.sectorNumber,\n        startDistance: boundary.startDistance,\n        endDistance: Math.min(boundary.endDistance, aligned.endDistance),\n        distance: sectorA.distance,\n        lapA: sectorA,\n        lapB: sectorB,\n        timeDelta,\n        avgSpeedDelta,\n        timeGainPercentage,\n      });\n    }\n\n    // Find best/worst performing sectors\n    const sortedSectors = [...sectors].sort((a, b) => a.timeDelta - b.timeDelta);\n    const fastestSector = sortedSectors[0];\n    const slowestSector = sortedSectors[sortedSectors.length - 1];\n\n    const totalTimeDelta = sectors.reduce((sum, s) => sum + s.timeDelta, 0);\n\n    return {\n      sectors,\n      summary: {\n        totalTimeDelta,\n        fastestSector: {\n          sectorNumber: fastestSector?.sectorNumber ?? 0,\n          timeDelta: fastestSector?.timeDelta ?? 0,\n        },\n        slowestSector: {\n          sectorNumber: slowestSector?.sectorNumber ?? 0,\n          timeDelta: slowestSector?.timeDelta ?? 0,\n        },\n      },\n    };\n  }\n\n  /**\n   * Get sector boundaries for track\n   * Uses configured boundaries if available, otherwise divides into thirds\n   */\n  private getSectorBoundaries(\n    trackName: string,\n    lap: NormalizedTelemetryPoint[]\n  ): SectorBoundary[] {\n    const sanitizedName = this.sanitizeTrackName(trackName);\n    const configured = this.sectorConfigs.get(sanitizedName);\n\n    if (configured) {\n      return configured;\n    }\n\n    return this.autoDetectSectors(lap);\n  }\n\n  /**\n   * Auto-detect sectors by dividing track into equal thirds\n   */\n  private autoDetectSectors(lap: NormalizedTelemetryPoint[]): SectorBoundary[] {\n    if (lap.length === 0) {\n      return [];\n    }\n\n    const trackLength = lap[lap.length - 1].distance - lap[0].distance;\n    const sectorLength = trackLength / 3;\n\n    return [\n      {\n        sectorNumber: 1,\n        startDistance: lap[0].distance,\n        endDistance: lap[0].distance + sectorLength,\n      },\n      {\n        sectorNumber: 2,\n        startDistance: lap[0].distance + sectorLength,\n        endDistance: lap[0].distance + sectorLength * 2,\n      },\n      {\n        sectorNumber: 3,\n        startDistance: lap[0].distance + sectorLength * 2,\n        endDistance: lap[lap.length - 1].distance,\n      },\n    ];\n  }\n\n  /**\n   * Calculate sector metrics for a single lap\n   */\n  private calculateSectorTime(\n    lap: NormalizedTelemetryPoint[],\n    boundary: SectorBoundary,\n    trackName: string,\n    trackId?: number\n  ): SectorTime {\n    const sectorPoints = lap.filter(\n      p => p.distance >= boundary.startDistance && p.distance <= boundary.endDistance\n    );\n\n    if (sectorPoints.length === 0) {\n      return {\n        sectorNumber: boundary.sectorNumber,\n        startDistance: boundary.startDistance,\n        endDistance: boundary.endDistance,\n        distance: 0,\n        time: 0,\n        avgSpeed: 0,\n        minSpeed: 0,\n        maxSpeed: 0,\n        avgThrottle: 0,\n        avgBrake: 0,\n        cornerCount: 0,\n      };\n    }\n\n    // Calculate time through sector\n    const startTime = sectorPoints[0].time;\n    const endTime = sectorPoints[sectorPoints.length - 1].time;\n    const time = endTime - startTime;\n\n    const distance = sectorPoints[sectorPoints.length - 1].distance - sectorPoints[0].distance;\n\n    // Speed metrics\n    const speeds = sectorPoints.map(p => p.speed);\n    const avgSpeed = this.average(speeds);\n    const minSpeed = Math.min(...speeds);\n    const maxSpeed = Math.max(...speeds);\n\n    // Input metrics\n    const avgThrottle = this.average(sectorPoints.map(p => p.throttle));\n    const avgBrake = this.average(sectorPoints.map(p => p.brake));\n\n    const cornerCount = this.countCornersInSector(\n      trackName,\n      trackId,\n      boundary.startDistance,\n      boundary.endDistance\n    );\n\n    return {\n      sectorNumber: boundary.sectorNumber,\n      startDistance: boundary.startDistance,\n      endDistance: boundary.endDistance,\n      distance,\n      time,\n      avgSpeed,\n      minSpeed,\n      maxSpeed,\n      avgThrottle,\n      avgBrake,\n      cornerCount,\n    };\n  }\n\n  /**\n   * Count corners in sector using corner database\n   */\n  private countCornersInSector(\n    trackName: string,\n    trackId: number | undefined,\n    startDistance: number,\n    endDistance: number\n  ): number {\n    const trackData = this.cornerDb.loadTrackCorners(trackName, trackId);\n\n    if (!trackData) {\n      return 0;\n    }\n\n    return trackData.corners.filter(\n      c => c.apexDistance >= startDistance && c.apexDistance <= endDistance\n    ).length;\n  }\n\n  /**\n   * Calculate average of numeric array\n   */\n  private average(values: number[]): number {\n    if (values.length === 0) return 0;\n    return values.reduce((sum, v) => sum + v, 0) / values.length;\n  }\n\n  /**\n   * Sanitize track name (extract from parentheses, lowercase, remove special chars)\n   */\n  private sanitizeTrackName(trackName: string): string {\n    const match = trackName.match(/\\(([^)]+)\\)/);\n    const baseName = match ? match[1] : trackName;\n\n    return baseName\n      .toLowerCase()\n      .trim()\n      .replace(/\\s+/g, '-')\n      .replace(/[^a-z0-9-]/g, '');\n  }\n\n  /**\n   * Add custom sector configuration for a track\n   */\n  addSectorConfig(config: SectorConfig): void {\n    const sanitizedName = this.sanitizeTrackName(config.trackName);\n    this.sectorConfigs.set(sanitizedName, config.sectors);\n  }\n\n  /**\n   * Format time delta with sign (+/-)\n   */\n  formatTimeDelta(seconds: number): string {\n    const sign = seconds >= 0 ? '+' : '';\n    return `${sign}${seconds.toFixed(3)}s`;\n  }\n\n  /**\n   * Get color for delta (green = faster, red = slower)\n   */\n  getDeltaColor(delta: number): 'green' | 'red' | 'neutral' {\n    if (delta < -0.01) return 'green';\n    if (delta > 0.01) return 'red';\n    return 'neutral';\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 720, "column": 0}, "map": {"version":3,"sources":["file:///Users/haseebulhaqmalik/Desktop/lap-lens/web/app/api/sectors/route.ts"],"sourcesContent":["import { NextResponse } from 'next/server';\nimport path from 'path';\nimport fs from 'fs';\nimport { LapLoader } from '@analysis/lap-loader';\nimport { LapNormalizer } from '@analysis/lap-normalizer';\nimport { LapAligner } from '@analysis/lap-aligner';\nimport { SectorAnalyzer } from '@analysis/sector-analysis';\n\nexport async function GET(request: Request) {\n  try {\n    const { searchParams } = new URL(request.url);\n    const currentLap = searchParams.get('current');\n    const referenceLap = searchParams.get('reference');\n\n    if (!currentLap || !referenceLap) {\n      return NextResponse.json(\n        { error: 'Missing lap parameters' },\n        { status: 400 }\n      );\n    }\n\n    const lapsDir = path.join(process.cwd(), '..', 'laps');\n    const cornersDir = path.join(process.cwd(), '..', 'corners');\n\n    const loader = new LapLoader(lapsDir);\n    const normalizer = new LapNormalizer({ sampleRate: 1.0 });\n    const aligner = new LapAligner();\n    const sectorAnalyzer = new SectorAnalyzer(cornersDir);\n\n    const availableLaps = loader.listAvailableLaps();\n    const lapAInfo = availableLaps.find(l => l.lapNumber === parseInt(currentLap));\n    const lapBInfo = availableLaps.find(l => l.lapNumber === parseInt(referenceLap));\n\n    if (!lapAInfo || !lapBInfo) {\n      return NextResponse.json({ error: 'Lap not found' }, { status: 404 });\n    }\n\n    const lapAMetadata = JSON.parse(fs.readFileSync(lapAInfo.filePath.replace('.csv', '.json'), 'utf-8'));\n    const trackName = lapAMetadata.trackName || 'Unknown';\n\n    const rawLapA = loader.loadLap(lapAInfo.filePath);\n    const rawLapB = loader.loadLap(lapBInfo.filePath);\n\n    const normalizedA = normalizer.normalize(rawLapA);\n    const normalizedB = normalizer.normalize(rawLapB);\n\n    const aligned = aligner.alignLaps(normalizedA, normalizedB);\n    const analysis = sectorAnalyzer.analyzeSectors(aligned, trackName);\n\n    const sectors = analysis.sectors.map((sector: any) => ({\n      sector: sector.sectorNumber,\n      current: sector.lapA.time,\n      reference: sector.lapB.time,\n      delta: sector.timeDelta,\n    }));\n\n    const totalCurrent = sectors.reduce((sum, s) => sum + s.current, 0);\n    const totalRef = sectors.reduce((sum, s) => sum + s.reference, 0);\n    const totalDelta = totalCurrent - totalRef;\n\n    return NextResponse.json({\n      sectors,\n      total: {\n        current: totalCurrent,\n        reference: totalRef,\n        delta: totalDelta,\n      },\n      metadata: {\n        currentLap: parseInt(currentLap),\n        referenceLap: parseInt(referenceLap),\n        track: trackName,\n      },\n    });\n  } catch (error) {\n    console.error('Error generating sector times:', error);\n    return NextResponse.json(\n      { error: 'Failed to generate sector times', details: String(error) },\n      { status: 500 }\n    );\n  }\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAEO,eAAe,IAAI,OAAgB;IACxC,IAAI;QACF,MAAM,EAAE,YAAY,EAAE,GAAG,IAAI,IAAI,QAAQ,GAAG;QAC5C,MAAM,aAAa,aAAa,GAAG,CAAC;QACpC,MAAM,eAAe,aAAa,GAAG,CAAC;QAEtC,IAAI,CAAC,cAAc,CAAC,cAAc;YAChC,OAAO,iLAAY,CAAC,IAAI,CACtB;gBAAE,OAAO;YAAyB,GAClC;gBAAE,QAAQ;YAAI;QAElB;QAEA,MAAM,UAAU,4GAAI,CAAC,IAAI,CAAC,QAAQ,GAAG,IAAI,MAAM;QAC/C,MAAM,aAAa,4GAAI,CAAC,IAAI,CAAC,QAAQ,GAAG,IAAI,MAAM;QAElD,MAAM,SAAS,IAAI,yKAAS,CAAC;QAC7B,MAAM,aAAa,IAAI,iLAAa,CAAC;YAAE,YAAY;QAAI;QACvD,MAAM,UAAU,IAAI,2KAAU;QAC9B,MAAM,iBAAiB,IAAI,mLAAc,CAAC;QAE1C,MAAM,gBAAgB,OAAO,iBAAiB;QAC9C,MAAM,WAAW,cAAc,IAAI,CAAC,CAAA,IAAK,EAAE,SAAS,KAAK,SAAS;QAClE,MAAM,WAAW,cAAc,IAAI,CAAC,CAAA,IAAK,EAAE,SAAS,KAAK,SAAS;QAElE,IAAI,CAAC,YAAY,CAAC,UAAU;YAC1B,OAAO,iLAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAAgB,GAAG;gBAAE,QAAQ;YAAI;QACrE;QAEA,MAAM,eAAe,KAAK,KAAK,CAAC,wGAAE,CAAC,YAAY,CAAC,SAAS,QAAQ,CAAC,OAAO,CAAC,QAAQ,UAAU;QAC5F,MAAM,YAAY,aAAa,SAAS,IAAI;QAE5C,MAAM,UAAU,OAAO,OAAO,CAAC,SAAS,QAAQ;QAChD,MAAM,UAAU,OAAO,OAAO,CAAC,SAAS,QAAQ;QAEhD,MAAM,cAAc,WAAW,SAAS,CAAC;QACzC,MAAM,cAAc,WAAW,SAAS,CAAC;QAEzC,MAAM,UAAU,QAAQ,SAAS,CAAC,aAAa;QAC/C,MAAM,WAAW,eAAe,cAAc,CAAC,SAAS;QAExD,MAAM,UAAU,SAAS,OAAO,CAAC,GAAG,CAAC,CAAC,SAAgB,CAAC;gBACrD,QAAQ,OAAO,YAAY;gBAC3B,SAAS,OAAO,IAAI,CAAC,IAAI;gBACzB,WAAW,OAAO,IAAI,CAAC,IAAI;gBAC3B,OAAO,OAAO,SAAS;YACzB,CAAC;QAED,MAAM,eAAe,QAAQ,MAAM,CAAC,CAAC,KAAK,IAAM,MAAM,EAAE,OAAO,EAAE;QACjE,MAAM,WAAW,QAAQ,MAAM,CAAC,CAAC,KAAK,IAAM,MAAM,EAAE,SAAS,EAAE;QAC/D,MAAM,aAAa,eAAe;QAElC,OAAO,iLAAY,CAAC,IAAI,CAAC;YACvB;YACA,OAAO;gBACL,SAAS;gBACT,WAAW;gBACX,OAAO;YACT;YACA,UAAU;gBACR,YAAY,SAAS;gBACrB,cAAc,SAAS;gBACvB,OAAO;YACT;QACF;IACF,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,kCAAkC;QAChD,OAAO,iLAAY,CAAC,IAAI,CACtB;YAAE,OAAO;YAAmC,SAAS,OAAO;QAAO,GACnE;YAAE,QAAQ;QAAI;IAElB;AACF"}}]
}