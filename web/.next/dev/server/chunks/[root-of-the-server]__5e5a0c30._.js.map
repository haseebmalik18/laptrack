{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 58, "column": 0}, "map": {"version":3,"sources":["file:///Users/haseebulhaqmalik/Desktop/lap-lens/src/analysis/lap-loader.ts"],"sourcesContent":["import * as fs from 'fs';\nimport * as path from 'path';\nimport { NormalizedTelemetryPoint } from '../types/f1-2024-packets';\n\nexport interface LapInfo {\n  filePath: string;\n  lapNumber: number;\n  timestamp: string;\n  pointCount: number;\n}\n\nexport class LapLoader {\n  private lapsDir: string;\n\n  constructor(lapsDir: string = './laps') {\n    this.lapsDir = lapsDir;\n  }\n\n  listAvailableLaps(): LapInfo[] {\n    if (!fs.existsSync(this.lapsDir)) {\n      return [];\n    }\n\n    const files = fs.readdirSync(this.lapsDir)\n      .filter(f => f.endsWith('.json'))\n      .map(f => {\n        const jsonPath = path.join(this.lapsDir, f);\n        const metadata = JSON.parse(fs.readFileSync(jsonPath, 'utf-8'));\n        return {\n          filePath: jsonPath.replace('.json', '.csv'),\n          lapNumber: metadata.lapNumber,\n          timestamp: metadata.timestamp,\n          pointCount: metadata.pointCount,\n        };\n      })\n      .sort((a, b) => a.lapNumber - b.lapNumber);\n\n    return files;\n  }\n\n  loadLap(csvPath: string): NormalizedTelemetryPoint[] {\n    const content = fs.readFileSync(csvPath, 'utf-8');\n    const lines = content.split('\\n').slice(1);\n\n    const points: NormalizedTelemetryPoint[] = [];\n\n    for (const line of lines) {\n      if (!line.trim()) continue;\n\n      const parts = line.split(',').map(p => parseFloat(p));\n      if (parts.length < 11) continue;\n\n      points.push({\n        time: parts[0],\n        distance: parts[1],\n        x: parts[2],\n        y: parts[3],\n        speed: parts[4],\n        throttle: parts[5],\n        brake: parts[6],\n        steering: parts[7],\n        gear: parts[8],\n        gLat: parts[9],\n        gLong: parts[10],\n        yaw: parts[11] || 0, // Backwards compatibility for old laps\n        lapNum: 0,\n      });\n    }\n\n    return points;\n  }\n\n  loadLapByNumber(lapNumber: number): NormalizedTelemetryPoint[] | null {\n    const laps = this.listAvailableLaps();\n    const lap = laps.find(l => l.lapNumber === lapNumber);\n\n    if (!lap) {\n      return null;\n    }\n\n    return this.loadLap(lap.filePath);\n  }\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AAUO,MAAM;IACH,QAAgB;IAExB,YAAY,UAAkB,QAAQ,CAAE;QACtC,IAAI,CAAC,OAAO,GAAG;IACjB;IAEA,oBAA+B;QAC7B,IAAI,CAAC,2GAAa,CAAC,IAAI,CAAC,OAAO,GAAG;YAChC,OAAO,EAAE;QACX;QAEA,MAAM,QAAQ,4GAAc,CAAC,IAAI,CAAC,OAAO,EACtC,MAAM,CAAC,CAAA,IAAK,EAAE,QAAQ,CAAC,UACvB,GAAG,CAAC,CAAA;YACH,MAAM,WAAW,yGAAS,CAAC,IAAI,CAAC,OAAO,EAAE;YACzC,MAAM,WAAW,KAAK,KAAK,CAAC,6GAAe,CAAC,UAAU;YACtD,OAAO;gBACL,UAAU,SAAS,OAAO,CAAC,SAAS;gBACpC,WAAW,SAAS,SAAS;gBAC7B,WAAW,SAAS,SAAS;gBAC7B,YAAY,SAAS,UAAU;YACjC;QACF,GACC,IAAI,CAAC,CAAC,GAAG,IAAM,EAAE,SAAS,GAAG,EAAE,SAAS;QAE3C,OAAO;IACT;IAEA,QAAQ,OAAe,EAA8B;QACnD,MAAM,UAAU,6GAAe,CAAC,SAAS;QACzC,MAAM,QAAQ,QAAQ,KAAK,CAAC,MAAM,KAAK,CAAC;QAExC,MAAM,SAAqC,EAAE;QAE7C,KAAK,MAAM,QAAQ,MAAO;YACxB,IAAI,CAAC,KAAK,IAAI,IAAI;YAElB,MAAM,QAAQ,KAAK,KAAK,CAAC,KAAK,GAAG,CAAC,CAAA,IAAK,WAAW;YAClD,IAAI,MAAM,MAAM,GAAG,IAAI;YAEvB,OAAO,IAAI,CAAC;gBACV,MAAM,KAAK,CAAC,EAAE;gBACd,UAAU,KAAK,CAAC,EAAE;gBAClB,GAAG,KAAK,CAAC,EAAE;gBACX,GAAG,KAAK,CAAC,EAAE;gBACX,OAAO,KAAK,CAAC,EAAE;gBACf,UAAU,KAAK,CAAC,EAAE;gBAClB,OAAO,KAAK,CAAC,EAAE;gBACf,UAAU,KAAK,CAAC,EAAE;gBAClB,MAAM,KAAK,CAAC,EAAE;gBACd,MAAM,KAAK,CAAC,EAAE;gBACd,OAAO,KAAK,CAAC,GAAG;gBAChB,KAAK,KAAK,CAAC,GAAG,IAAI;gBAClB,QAAQ;YACV;QACF;QAEA,OAAO;IACT;IAEA,gBAAgB,SAAiB,EAAqC;QACpE,MAAM,OAAO,IAAI,CAAC,iBAAiB;QACnC,MAAM,MAAM,KAAK,IAAI,CAAC,CAAA,IAAK,EAAE,SAAS,KAAK;QAE3C,IAAI,CAAC,KAAK;YACR,OAAO;QACT;QAEA,OAAO,IAAI,CAAC,OAAO,CAAC,IAAI,QAAQ;IAClC;AACF"}},
    {"offset": {"line": 126, "column": 0}, "map": {"version":3,"sources":["file:///Users/haseebulhaqmalik/Desktop/lap-lens/src/analysis/track-map-loader.ts"],"sourcesContent":["import * as fs from 'fs';\nimport * as path from 'path';\n\nexport interface TrackMapPoint {\n  x: number;\n  y: number;\n  widthRight: number;\n  widthLeft: number;\n}\n\nexport interface TrackMap {\n  name: string;\n  points: TrackMapPoint[];\n  bounds: {\n    minX: number;\n    maxX: number;\n    minY: number;\n    maxY: number;\n  };\n}\n\nexport class TrackMapLoader {\n  private mapsDir: string;\n\n  constructor(mapsDir: string = './track-maps') {\n    this.mapsDir = mapsDir;\n  }\n\n  loadTrackMap(trackName: string): TrackMap | null {\n    const csvPath = path.join(this.mapsDir, `${trackName.toLowerCase()}.csv`);\n\n    if (!fs.existsSync(csvPath)) {\n      console.error(`Track map not found: ${csvPath}`);\n      return null;\n    }\n\n    const content = fs.readFileSync(csvPath, 'utf-8');\n    const lines = content.split('\\n').slice(1); // Skip header\n\n    const points: TrackMapPoint[] = [];\n    let minX = Infinity, maxX = -Infinity;\n    let minY = Infinity, maxY = -Infinity;\n\n    for (const line of lines) {\n      if (!line.trim()) continue;\n\n      const parts = line.split(',').map(p => parseFloat(p));\n      if (parts.length < 4) continue;\n\n      const point: TrackMapPoint = {\n        x: parts[0],\n        y: parts[1],\n        widthRight: parts[2],\n        widthLeft: parts[3],\n      };\n\n      points.push(point);\n\n      minX = Math.min(minX, point.x);\n      maxX = Math.max(maxX, point.x);\n      minY = Math.min(minY, point.y);\n      maxY = Math.max(maxY, point.y);\n    }\n\n    return {\n      name: trackName,\n      points,\n      bounds: { minX, maxX, minY, maxY },\n    };\n  }\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AAoBO,MAAM;IACH,QAAgB;IAExB,YAAY,UAAkB,cAAc,CAAE;QAC5C,IAAI,CAAC,OAAO,GAAG;IACjB;IAEA,aAAa,SAAiB,EAAmB;QAC/C,MAAM,UAAU,yGAAS,CAAC,IAAI,CAAC,OAAO,EAAE,GAAG,UAAU,WAAW,GAAG,IAAI,CAAC;QAExE,IAAI,CAAC,2GAAa,CAAC,UAAU;YAC3B,QAAQ,KAAK,CAAC,CAAC,qBAAqB,EAAE,SAAS;YAC/C,OAAO;QACT;QAEA,MAAM,UAAU,6GAAe,CAAC,SAAS;QACzC,MAAM,QAAQ,QAAQ,KAAK,CAAC,MAAM,KAAK,CAAC,IAAI,cAAc;QAE1D,MAAM,SAA0B,EAAE;QAClC,IAAI,OAAO,UAAU,OAAO,CAAC;QAC7B,IAAI,OAAO,UAAU,OAAO,CAAC;QAE7B,KAAK,MAAM,QAAQ,MAAO;YACxB,IAAI,CAAC,KAAK,IAAI,IAAI;YAElB,MAAM,QAAQ,KAAK,KAAK,CAAC,KAAK,GAAG,CAAC,CAAA,IAAK,WAAW;YAClD,IAAI,MAAM,MAAM,GAAG,GAAG;YAEtB,MAAM,QAAuB;gBAC3B,GAAG,KAAK,CAAC,EAAE;gBACX,GAAG,KAAK,CAAC,EAAE;gBACX,YAAY,KAAK,CAAC,EAAE;gBACpB,WAAW,KAAK,CAAC,EAAE;YACrB;YAEA,OAAO,IAAI,CAAC;YAEZ,OAAO,KAAK,GAAG,CAAC,MAAM,MAAM,CAAC;YAC7B,OAAO,KAAK,GAAG,CAAC,MAAM,MAAM,CAAC;YAC7B,OAAO,KAAK,GAAG,CAAC,MAAM,MAAM,CAAC;YAC7B,OAAO,KAAK,GAAG,CAAC,MAAM,MAAM,CAAC;QAC/B;QAEA,OAAO;YACL,MAAM;YACN;YACA,QAAQ;gBAAE;gBAAM;gBAAM;gBAAM;YAAK;QACnC;IACF;AACF"}},
    {"offset": {"line": 182, "column": 0}, "map": {"version":3,"sources":["file:///Users/haseebulhaqmalik/Desktop/lap-lens/src/analysis/telemetry-aligner.ts"],"sourcesContent":["import { NormalizedTelemetryPoint } from '../types/f1-2024-packets';\nimport { TrackMap } from './track-map-loader';\n\nexport interface AlignmentTransform {\n  scale: number;\n  rotation: number;\n  translateX: number;\n  translateY: number;\n}\n\nexport class TelemetryAligner {\n  /**\n   * Aligns telemetry data to a reference track map\n   * This implements the Track Titan approach: transform telemetry to match track outline\n   */\n  alignToTrackMap(\n    telemetry: NormalizedTelemetryPoint[],\n    trackMap: TrackMap\n  ): { aligned: NormalizedTelemetryPoint[]; transform: AlignmentTransform } {\n    // Step 1: Calculate bounds of telemetry (using rotated coordinates)\n    const telemetryPoints = telemetry.map(p => ({\n      x: p.y!,  // Rotate: rx = y\n      y: -p.x!, // ry = -x\n    }));\n\n    const telBounds = this.getBounds(telemetryPoints);\n    const trackBounds = trackMap.bounds;\n\n    // Step 2: Calculate scale factor to match track length\n    const telRangeX = telBounds.maxX - telBounds.minX;\n    const telRangeY = telBounds.maxY - telBounds.minY;\n    const trackRangeX = trackBounds.maxX - trackBounds.minX;\n    const trackRangeY = trackBounds.maxY - trackBounds.minY;\n\n    const scaleX = trackRangeX / telRangeX;\n    const scaleY = trackRangeY / telRangeY;\n    const scale = (scaleX + scaleY) / 2; // Average scale\n\n    // Step 3: Calculate translation to center\n    const telCenterX = (telBounds.minX + telBounds.maxX) / 2;\n    const telCenterY = (telBounds.minY + telBounds.maxY) / 2;\n    const trackCenterX = (trackBounds.minX + trackBounds.maxX) / 2;\n    const trackCenterY = (trackBounds.minY + trackBounds.maxY) / 2;\n\n    const translateX = trackCenterX - telCenterX * scale;\n    const translateY = trackCenterY - telCenterY * scale;\n\n    // Step 4: Apply transformation\n    const aligned = telemetry.map(p => ({\n      ...p,\n      // Transform: rotate, scale, translate\n      x: (p.y! * scale + translateX),\n      y: (-p.x! * scale + translateY),\n    }));\n\n    return {\n      aligned,\n      transform: {\n        scale,\n        rotation: 270, // We applied 270-degree rotation\n        translateX,\n        translateY,\n      },\n    };\n  }\n\n  private getBounds(points: { x: number; y: number }[]): {\n    minX: number;\n    maxX: number;\n    minY: number;\n    maxY: number;\n  } {\n    let minX = Infinity, maxX = -Infinity;\n    let minY = Infinity, maxY = -Infinity;\n\n    for (const p of points) {\n      minX = Math.min(minX, p.x);\n      maxX = Math.max(maxX, p.x);\n      minY = Math.min(minY, p.y);\n      maxY = Math.max(maxY, p.y);\n    }\n\n    return { minX, maxX, minY, maxY };\n  }\n}\n"],"names":[],"mappings":";;;;AAUO,MAAM;IACX;;;GAGC,GACD,gBACE,SAAqC,EACrC,QAAkB,EACsD;QACxE,oEAAoE;QACpE,MAAM,kBAAkB,UAAU,GAAG,CAAC,CAAA,IAAK,CAAC;gBAC1C,GAAG,EAAE,CAAC;gBACN,GAAG,CAAC,EAAE,CAAC;YACT,CAAC;QAED,MAAM,YAAY,IAAI,CAAC,SAAS,CAAC;QACjC,MAAM,cAAc,SAAS,MAAM;QAEnC,uDAAuD;QACvD,MAAM,YAAY,UAAU,IAAI,GAAG,UAAU,IAAI;QACjD,MAAM,YAAY,UAAU,IAAI,GAAG,UAAU,IAAI;QACjD,MAAM,cAAc,YAAY,IAAI,GAAG,YAAY,IAAI;QACvD,MAAM,cAAc,YAAY,IAAI,GAAG,YAAY,IAAI;QAEvD,MAAM,SAAS,cAAc;QAC7B,MAAM,SAAS,cAAc;QAC7B,MAAM,QAAQ,CAAC,SAAS,MAAM,IAAI,GAAG,gBAAgB;QAErD,0CAA0C;QAC1C,MAAM,aAAa,CAAC,UAAU,IAAI,GAAG,UAAU,IAAI,IAAI;QACvD,MAAM,aAAa,CAAC,UAAU,IAAI,GAAG,UAAU,IAAI,IAAI;QACvD,MAAM,eAAe,CAAC,YAAY,IAAI,GAAG,YAAY,IAAI,IAAI;QAC7D,MAAM,eAAe,CAAC,YAAY,IAAI,GAAG,YAAY,IAAI,IAAI;QAE7D,MAAM,aAAa,eAAe,aAAa;QAC/C,MAAM,aAAa,eAAe,aAAa;QAE/C,+BAA+B;QAC/B,MAAM,UAAU,UAAU,GAAG,CAAC,CAAA,IAAK,CAAC;gBAClC,GAAG,CAAC;gBACJ,sCAAsC;gBACtC,GAAI,EAAE,CAAC,GAAI,QAAQ;gBACnB,GAAI,CAAC,EAAE,CAAC,GAAI,QAAQ;YACtB,CAAC;QAED,OAAO;YACL;YACA,WAAW;gBACT;gBACA,UAAU;gBACV;gBACA;YACF;QACF;IACF;IAEQ,UAAU,MAAkC,EAKlD;QACA,IAAI,OAAO,UAAU,OAAO,CAAC;QAC7B,IAAI,OAAO,UAAU,OAAO,CAAC;QAE7B,KAAK,MAAM,KAAK,OAAQ;YACtB,OAAO,KAAK,GAAG,CAAC,MAAM,EAAE,CAAC;YACzB,OAAO,KAAK,GAAG,CAAC,MAAM,EAAE,CAAC;YACzB,OAAO,KAAK,GAAG,CAAC,MAAM,EAAE,CAAC;YACzB,OAAO,KAAK,GAAG,CAAC,MAAM,EAAE,CAAC;QAC3B;QAEA,OAAO;YAAE;YAAM;YAAM;YAAM;QAAK;IAClC;AACF"}},
    {"offset": {"line": 251, "column": 0}, "map": {"version":3,"sources":["file:///Users/haseebulhaqmalik/Desktop/lap-lens/web/app/api/laps/%5BlapNumber%5D/route.ts"],"sourcesContent":["import { NextResponse } from \"next/server\";\nimport path from \"path\";\nimport fs from \"fs\";\nimport { LapLoader } from \"../../../../../src/analysis/lap-loader\";\nimport { TrackMapLoader } from \"../../../../../src/analysis/track-map-loader\";\nimport { TelemetryAligner } from \"../../../../../src/analysis/telemetry-aligner\";\n\nexport async function GET(\n  _request: Request,\n  { params }: { params: Promise<{ lapNumber: string }> }\n) {\n  const { lapNumber } = await params;\n  const lapsDir = path.join(process.cwd(), \"..\", \"laps\");\n  const loader = new LapLoader(lapsDir);\n\n  const lapInfo = loader.listAvailableLaps().find(\n    l => l.lapNumber === parseInt(lapNumber)\n  );\n\n  if (!lapInfo) {\n    return NextResponse.json({ error: \"Lap not found\" }, { status: 404 });\n  }\n\n  const rawTelemetry = loader.loadLap(lapInfo.filePath);\n  const metadataPath = lapInfo.filePath.replace('.csv', '.json');\n\n  let metadata: any = {};\n  try {\n    if (fs.existsSync(metadataPath)) {\n      metadata = JSON.parse(fs.readFileSync(metadataPath, 'utf-8'));\n    }\n  } catch (err) {\n    console.error('Failed to read metadata:', err);\n  }\n\n  // Load track map and align telemetry (Track Titan approach)\n  const trackMapsDir = path.join(process.cwd(), \"..\", \"track-maps\");\n  const trackMapLoader = new TrackMapLoader(trackMapsDir);\n\n  // Extract track name (e.g., \"Sakhir (Bahrain)\" -> \"sakhir\")\n  const trackName = metadata.trackName || \"Unknown\";\n  const simpleName = trackName.match(/\\(([^)]+)\\)/)\n    ? trackName.match(/\\(([^)]+)\\)/)[1].toLowerCase()\n    : trackName.toLowerCase();\n\n  const trackMap = trackMapLoader.loadTrackMap(simpleName === 'bahrain' ? 'sakhir' : simpleName);\n\n  let telemetry = rawTelemetry;\n  let trackMapData = null;\n\n  if (trackMap) {\n    // Align telemetry to track map\n    const aligner = new TelemetryAligner();\n    const aligned = aligner.alignToTrackMap(rawTelemetry, trackMap);\n    telemetry = aligned.aligned;\n    trackMapData = trackMap;\n    console.log('Track map loaded and aligned:', trackMap.name);\n  } else {\n    console.log('No track map found for:', simpleName);\n  }\n\n  return NextResponse.json({\n    lapNumber: parseInt(lapNumber),\n    metadata,\n    telemetry,\n    trackMap: trackMapData,\n  });\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAEO,eAAe,IACpB,QAAiB,EACjB,EAAE,MAAM,EAA8C;IAEtD,MAAM,EAAE,SAAS,EAAE,GAAG,MAAM;IAC5B,MAAM,UAAU,4GAAI,CAAC,IAAI,CAAC,QAAQ,GAAG,IAAI,MAAM;IAC/C,MAAM,SAAS,IAAI,yKAAS,CAAC;IAE7B,MAAM,UAAU,OAAO,iBAAiB,GAAG,IAAI,CAC7C,CAAA,IAAK,EAAE,SAAS,KAAK,SAAS;IAGhC,IAAI,CAAC,SAAS;QACZ,OAAO,iLAAY,CAAC,IAAI,CAAC;YAAE,OAAO;QAAgB,GAAG;YAAE,QAAQ;QAAI;IACrE;IAEA,MAAM,eAAe,OAAO,OAAO,CAAC,QAAQ,QAAQ;IACpD,MAAM,eAAe,QAAQ,QAAQ,CAAC,OAAO,CAAC,QAAQ;IAEtD,IAAI,WAAgB,CAAC;IACrB,IAAI;QACF,IAAI,wGAAE,CAAC,UAAU,CAAC,eAAe;YAC/B,WAAW,KAAK,KAAK,CAAC,wGAAE,CAAC,YAAY,CAAC,cAAc;QACtD;IACF,EAAE,OAAO,KAAK;QACZ,QAAQ,KAAK,CAAC,4BAA4B;IAC5C;IAEA,4DAA4D;IAC5D,MAAM,eAAe,4GAAI,CAAC,IAAI,CAAC,QAAQ,GAAG,IAAI,MAAM;IACpD,MAAM,iBAAiB,IAAI,uLAAc,CAAC;IAE1C,4DAA4D;IAC5D,MAAM,YAAY,SAAS,SAAS,IAAI;IACxC,MAAM,aAAa,UAAU,KAAK,CAAC,iBAC/B,UAAU,KAAK,CAAC,cAAc,CAAC,EAAE,CAAC,WAAW,KAC7C,UAAU,WAAW;IAEzB,MAAM,WAAW,eAAe,YAAY,CAAC,eAAe,YAAY,WAAW;IAEnF,IAAI,YAAY;IAChB,IAAI,eAAe;IAEnB,IAAI,UAAU;QACZ,+BAA+B;QAC/B,MAAM,UAAU,IAAI,uLAAgB;QACpC,MAAM,UAAU,QAAQ,eAAe,CAAC,cAAc;QACtD,YAAY,QAAQ,OAAO;QAC3B,eAAe;QACf,QAAQ,GAAG,CAAC,iCAAiC,SAAS,IAAI;IAC5D,OAAO;QACL,QAAQ,GAAG,CAAC,2BAA2B;IACzC;IAEA,OAAO,iLAAY,CAAC,IAAI,CAAC;QACvB,WAAW,SAAS;QACpB;QACA;QACA,UAAU;IACZ;AACF"}}]
}